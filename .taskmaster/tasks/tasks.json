{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Supabase Database Schema",
        "description": "Design and implement the database schema in Supabase to store calendar collections persistently",
        "details": "1. Create a new table called 'calendar_collections' in Supabase with the following columns:\n   - guid: UUID (primary key)\n   - name: TEXT (not null)\n   - description: TEXT\n   - sources: JSONB (not null)\n   - created_at: TIMESTAMP WITH TIME ZONE (default: now())\n   - updated_at: TIMESTAMP WITH TIME ZONE (default: now())\n\n2. Set up appropriate indexes:\n   - Primary key on guid\n   - Index on created_at for potential sorting/filtering\n\n3. Configure Row Level Security (RLS) policies if needed for future user authentication\n\n4. Create a TypeScript interface that matches the CalendarCollection type but includes the additional database fields:\n\n```typescript\ninterface StoredCalendarCollection extends CalendarCollection {\n  created_at: string;\n  updated_at: string;\n}\n```",
        "testStrategy": "1. Verify table creation in Supabase dashboard\n2. Test inserting a sample record manually through the Supabase interface\n3. Confirm data types are correctly defined, especially the JSONB for sources\n4. Validate that created_at and updated_at fields are automatically populated\n5. Ensure the schema matches the existing CalendarCollection TypeScript type",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Supabase Client Configuration",
        "description": "Set up Supabase client integration with environment variables for the application",
        "details": "1. Install required dependencies:\n```bash\nnpm install @supabase/supabase-js\n```\n\n2. Create a utility file for Supabase client initialization (e.g., `lib/supabase.ts`):\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n\n3. Update environment configuration:\n   - Add the following to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n   - Update `.env.example` to include these variables\n   - Update deployment documentation to include Supabase environment variables\n\n4. Create a simple test function to verify connection:\n```typescript\nexport async function testSupabaseConnection() {\n  try {\n    const { data, error } = await supabase.from('calendar_collections').select('count');\n    if (error) throw error;\n    return { success: true };\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return { success: false, error };\n  }\n}\n```",
        "testStrategy": "1. Create a simple test endpoint that calls testSupabaseConnection()\n2. Verify connection succeeds with valid environment variables\n3. Verify appropriate error handling when environment variables are missing\n4. Test connection in both development and production environments\n5. Ensure environment variables are properly loaded in all environments",
        "priority": "high",
        "dependencies": [1],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update API Routes for Supabase Integration",
        "description": "Refactor existing API routes to use Supabase for persistent storage instead of in-memory storage",
        "details": "1. Create a service layer for calendar collections (e.g., `services/calendarCollections.ts`):\n```typescript\nimport { supabase } from '../lib/supabase';\nimport { v4 as uuidv4 } from 'uuid';\nimport { CalendarCollection } from '../types';\n\nexport async function getAllCollections() {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .order('created_at', { ascending: false });\n  \n  if (error) throw error;\n  return data as CalendarCollection[];\n}\n\nexport async function getCollectionByGuid(guid: string) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .eq('guid', guid)\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function createCollection(collection: Omit<CalendarCollection, 'guid'>) {\n  const guid = uuidv4();\n  const newCollection = { ...collection, guid };\n  \n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .insert([newCollection])\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function updateCollection(guid: string, updates: Partial<CalendarCollection>) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .update({ ...updates, updated_at: new Date() })\n    .eq('guid', guid)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function deleteCollection(guid: string) {\n  const { error } = await supabase\n    .from('calendar_collections')\n    .delete()\n    .eq('guid', guid);\n  \n  if (error) throw error;\n  return { success: true };\n}\n```\n\n2. Update API routes to use the service layer:\n\n- `/api/collections.ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getAllCollections, createCollection } from '../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    if (req.method === 'GET') {\n      const collections = await getAllCollections();\n      return res.status(200).json(collections);\n    } else if (req.method === 'POST') {\n      const collection = await createCollection(req.body);\n      return res.status(201).json(collection);\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n- `/api/collections/[guid].ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getCollectionByGuid, updateCollection, deleteCollection } from '../../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { guid } = req.query;\n  \n  if (!guid || Array.isArray(guid)) {\n    return res.status(400).json({ message: 'Invalid guid parameter' });\n  }\n  \n  try {\n    if (req.method === 'GET') {\n      const collection = await getCollectionByGuid(guid);\n      return res.status(200).json(collection);\n    } else if (req.method === 'PUT') {\n      const collection = await updateCollection(guid, req.body);\n      return res.status(200).json(collection);\n    } else if (req.method === 'DELETE') {\n      await deleteCollection(guid);\n      return res.status(204).end();\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n3. Add backward compatibility with existing in-memory storage during transition:\n```typescript\n// In the service layer, add fallback to in-memory storage\nexport async function getAllCollections() {\n  try {\n    const { data, error } = await supabase\n      .from('calendar_collections')\n      .select('*')\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data as CalendarCollection[];\n  } catch (error) {\n    console.warn('Falling back to in-memory storage', error);\n    return globalThis.calendarCollections || [];\n  }\n}\n```",
        "testStrategy": "1. Create unit tests for each service function\n2. Test each API endpoint with valid and invalid requests\n3. Verify error handling for database connection issues\n4. Test backward compatibility with existing API response format\n5. Verify CRUD operations work correctly with Supabase\n6. Test performance and response times compared to in-memory storage\n7. Ensure proper error responses for invalid requests",
        "priority": "medium",
        "dependencies": [1, 2],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Deployment and Documentation Updates",
        "description": "Update deployment process and documentation to include Supabase integration requirements",
        "details": "1. Update README.md with Supabase setup instructions:\n```markdown\n## Supabase Setup\n\n1. Create a Supabase project at https://supabase.com\n2. Create the `calendar_collections` table using the SQL in `schema.sql`\n3. Get your Supabase URL and anon key from the project settings\n4. Add these to your environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n```\n\n2. Create a `schema.sql` file with the table creation SQL:\n```sql\nCREATE TABLE calendar_collections (\n  guid UUID PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  sources JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE INDEX idx_calendar_collections_created_at ON calendar_collections(created_at);\n```\n\n3. Update deployment scripts or configuration:\n   - Add Supabase environment variables to deployment platform (Vercel, Netlify, etc.)\n   - Create a deployment checklist that includes Supabase setup\n\n4. Create a simple health check endpoint to verify Supabase connection:\n```typescript\n// pages/api/health.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { testSupabaseConnection } from '../../lib/supabase';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ message: 'Method not allowed' });\n  }\n\n  try {\n    const connectionStatus = await testSupabaseConnection();\n    return res.status(200).json({\n      status: 'ok',\n      supabase: connectionStatus.success ? 'connected' : 'error',\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error('Health check error:', error);\n    return res.status(500).json({ status: 'error', message: 'Internal server error' });\n  }\n}\n```\n\n5. Add logging for monitoring database operations in production",
        "testStrategy": "1. Verify README.md instructions are clear and complete\n2. Test schema.sql script in a fresh Supabase project\n3. Verify health check endpoint correctly reports connection status\n4. Test deployment process on staging environment\n5. Verify environment variables are correctly set in production\n6. Create a deployment checklist and verify all steps\n7. Test the application after deployment to ensure collections persist",
        "priority": "low",
        "dependencies": [1, 2, 3],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-20T06:49:44.250Z",
      "updated": "2025-08-20T06:49:58.088Z",
      "description": "Tasks for master context"
    }
  },
  "supabase-backend": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Supabase Database Schema",
        "description": "Design and implement the database schema in Supabase to store calendar collections persistently",
        "details": "1. Create a new table called 'calendar_collections' in Supabase with the following columns:\n   - guid: UUID (primary key)\n   - name: TEXT (not null)\n   - description: TEXT\n   - sources: JSONB (not null)\n   - created_at: TIMESTAMP WITH TIME ZONE (default: now())\n   - updated_at: TIMESTAMP WITH TIME ZONE (default: now())\n\n2. Set up appropriate indexes:\n   - Primary key on guid\n   - Index on created_at for potential sorting/filtering\n\n3. Configure Row Level Security (RLS) policies if needed for future user authentication\n\n4. Create a TypeScript interface that matches the CalendarCollection type but includes the additional database fields:\n\n```typescript\ninterface StoredCalendarCollection extends CalendarCollection {\n  created_at: string;\n  updated_at: string;\n}\n```",
        "testStrategy": "1. Verify table creation in Supabase dashboard\n2. Test inserting a sample record manually through the Supabase interface\n3. Confirm data types are correctly defined, especially the JSONB for sources\n4. Validate that created_at and updated_at fields are automatically populated\n5. Ensure the schema matches the existing CalendarCollection TypeScript type",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Supabase Client Configuration",
        "description": "Set up Supabase client integration with environment variables for the application",
        "details": "1. Install required dependencies:\n```bash\nnpm install @supabase/supabase-js\n```\n\n2. Create a utility file for Supabase client initialization (e.g., `lib/supabase.ts`):\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n\n3. Update environment configuration:\n   - Add the following to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n   - Update `.env.example` to include these variables\n   - Update deployment documentation to include Supabase environment variables\n\n4. Create a simple test function to verify connection:\n```typescript\nexport async function testSupabaseConnection() {\n  try {\n    const { data, error } = await supabase.from('calendar_collections').select('count');\n    if (error) throw error;\n    return { success: true };\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return { success: false, error };\n  }\n}\n```",
        "testStrategy": "1. Create a simple test endpoint that calls testSupabaseConnection()\n2. Verify connection succeeds with valid environment variables\n3. Verify appropriate error handling when environment variables are missing\n4. Test connection in both development and production environments\n5. Ensure environment variables are properly loaded in all environments",
        "priority": "high",
        "dependencies": [1],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update API Routes for Supabase Integration",
        "description": "Refactor existing API routes to use Supabase for persistent storage instead of in-memory storage",
        "details": "1. Create a service layer for calendar collections (e.g., `services/calendarCollections.ts`):\n```typescript\nimport { supabase } from '../lib/supabase';\nimport { v4 as uuidv4 } from 'uuid';\nimport { CalendarCollection } from '../types';\n\nexport async function getAllCollections() {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .order('created_at', { ascending: false });\n  \n  if (error) throw error;\n  return data as CalendarCollection[];\n}\n\nexport async function getCollectionByGuid(guid: string) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .eq('guid', guid)\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function createCollection(collection: Omit<CalendarCollection, 'guid'>) {\n  const guid = uuidv4();\n  const newCollection = { ...collection, guid };\n  \n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .insert([newCollection])\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function updateCollection(guid: string, updates: Partial<CalendarCollection>) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .update({ ...updates, updated_at: new Date() })\n    .eq('guid', guid)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function deleteCollection(guid: string) {\n  const { error } = await supabase\n    .from('calendar_collections')\n    .delete()\n    .eq('guid', guid);\n  \n  if (error) throw error;\n  return { success: true };\n}\n```\n\n2. Update API routes to use the service layer:\n\n- `/api/collections.ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getAllCollections, createCollection } from '../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    if (req.method === 'GET') {\n      const collections = await getAllCollections();\n      return res.status(200).json(collections);\n    } else if (req.method === 'POST') {\n      const collection = await createCollection(req.body);\n      return res.status(201).json(collection);\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n- `/api/collections/[guid].ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getCollectionByGuid, updateCollection, deleteCollection } from '../../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { guid } = req.query;\n  \n  if (!guid || Array.isArray(guid)) {\n    return res.status(400).json({ message: 'Invalid guid parameter' });\n  }\n  \n  try {\n    if (req.method === 'GET') {\n      const collection = await getCollectionByGuid(guid);\n      return res.status(200).json(collection);\n    } else if (req.method === 'PUT') {\n      const collection = await updateCollection(guid, req.body);\n      return res.status(200).json(collection);\n    } else if (req.method === 'DELETE') {\n      await deleteCollection(guid);\n      return res.status(204).end();\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n3. Add backward compatibility with existing in-memory storage during transition:\n```typescript\n// In the service layer, add fallback to in-memory storage\nexport async function getAllCollections() {\n  try {\n    const { data, error } = await supabase\n      .from('calendar_collections')\n      .select('*')\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data as CalendarCollection[];\n  } catch (error) {\n    console.warn('Falling back to in-memory storage', error);\n    return globalThis.calendarCollections || [];\n  }\n}\n```",
        "testStrategy": "1. Create unit tests for each service function\n2. Test each API endpoint with valid and invalid requests\n3. Verify error handling for database connection issues\n4. Test backward compatibility with existing API response format\n5. Verify CRUD operations work correctly with Supabase\n6. Test performance and response times compared to in-memory storage\n7. Ensure proper error responses for invalid requests",
        "priority": "medium",
        "dependencies": [1, 2],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Deployment and Documentation Updates",
        "description": "Update deployment process and documentation to include Supabase integration requirements",
        "details": "1. Update README.md with Supabase setup instructions:\n```markdown\n## Supabase Setup\n\n1. Create a Supabase project at https://supabase.com\n2. Create the `calendar_collections` table using the SQL in `schema.sql`\n3. Get your Supabase URL and anon key from the project settings\n4. Add these to your environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n```\n\n2. Create a `schema.sql` file with the table creation SQL:\n```sql\nCREATE TABLE calendar_collections (\n  guid UUID PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  sources JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE INDEX idx_calendar_collections_created_at ON calendar_collections(created_at);\n```\n\n3. Update deployment scripts or configuration:\n   - Add Supabase environment variables to deployment platform (Vercel, Netlify, etc.)\n   - Create a deployment checklist that includes Supabase setup\n\n4. Create a simple health check endpoint to verify Supabase connection:\n```typescript\n// pages/api/health.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { testSupabaseConnection } from '../../lib/supabase';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ message: 'Method not allowed' });\n  }\n\n  try {\n    const connectionStatus = await testSupabaseConnection();\n    return res.status(200).json({\n      status: 'ok',\n      supabase: connectionStatus.success ? 'connected' : 'error',\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error('Health check error:', error);\n    return res.status(500).json({ status: 'error', message: 'Internal server error' });\n  }\n}\n```\n\n5. Add logging for monitoring database operations in production",
        "testStrategy": "1. Verify README.md instructions are clear and complete\n2. Test schema.sql script in a fresh Supabase project\n3. Verify health check endpoint correctly reports connection status\n4. Test deployment process on staging environment\n5. Verify environment variables are correctly set in production\n6. Create a deployment checklist and verify all steps\n7. Test the application after deployment to ensure collections persist",
        "priority": "low",
        "dependencies": [1, 2, 3],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-20T06:50:18.280Z",
      "updated": "2025-08-20T07:10:03.790Z",
      "description": "Implement Supabase backend for persistent calendar GUID storage"
    }
  }
}
