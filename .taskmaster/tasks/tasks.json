{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Supabase Database Schema",
        "description": "Design and implement the database schema in Supabase to store calendar collections persistently",
        "details": "1. Create a new table called 'calendar_collections' in Supabase with the following columns:\n   - guid: UUID (primary key)\n   - name: TEXT (not null)\n   - description: TEXT\n   - sources: JSONB (not null)\n   - created_at: TIMESTAMP WITH TIME ZONE (default: now())\n   - updated_at: TIMESTAMP WITH TIME ZONE (default: now())\n\n2. Set up appropriate indexes:\n   - Primary key on guid\n   - Index on created_at for potential sorting/filtering\n\n3. Configure Row Level Security (RLS) policies if needed for future user authentication\n\n4. Create a TypeScript interface that matches the CalendarCollection type but includes the additional database fields:\n\n```typescript\ninterface StoredCalendarCollection extends CalendarCollection {\n  created_at: string;\n  updated_at: string;\n}\n```",
        "testStrategy": "1. Verify table creation in Supabase dashboard\n2. Test inserting a sample record manually through the Supabase interface\n3. Confirm data types are correctly defined, especially the JSONB for sources\n4. Validate that created_at and updated_at fields are automatically populated\n5. Ensure the schema matches the existing CalendarCollection TypeScript type",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Supabase Client Configuration",
        "description": "Set up Supabase client integration with environment variables for the application",
        "details": "1. Install required dependencies:\n```bash\nnpm install @supabase/supabase-js\n```\n\n2. Create a utility file for Supabase client initialization (e.g., `lib/supabase.ts`):\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n\n3. Update environment configuration:\n   - Add the following to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n   - Update `.env.example` to include these variables\n   - Update deployment documentation to include Supabase environment variables\n\n4. Create a simple test function to verify connection:\n```typescript\nexport async function testSupabaseConnection() {\n  try {\n    const { data, error } = await supabase.from('calendar_collections').select('count');\n    if (error) throw error;\n    return { success: true };\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return { success: false, error };\n  }\n}\n```",
        "testStrategy": "1. Create a simple test endpoint that calls testSupabaseConnection()\n2. Verify connection succeeds with valid environment variables\n3. Verify appropriate error handling when environment variables are missing\n4. Test connection in both development and production environments\n5. Ensure environment variables are properly loaded in all environments",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update API Routes for Supabase Integration",
        "description": "Refactor existing API routes to use Supabase for persistent storage instead of in-memory storage",
        "details": "1. Create a service layer for calendar collections (e.g., `services/calendarCollections.ts`):\n```typescript\nimport { supabase } from '../lib/supabase';\nimport { v4 as uuidv4 } from 'uuid';\nimport { CalendarCollection } from '../types';\n\nexport async function getAllCollections() {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .order('created_at', { ascending: false });\n  \n  if (error) throw error;\n  return data as CalendarCollection[];\n}\n\nexport async function getCollectionByGuid(guid: string) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .eq('guid', guid)\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function createCollection(collection: Omit<CalendarCollection, 'guid'>) {\n  const guid = uuidv4();\n  const newCollection = { ...collection, guid };\n  \n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .insert([newCollection])\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function updateCollection(guid: string, updates: Partial<CalendarCollection>) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .update({ ...updates, updated_at: new Date() })\n    .eq('guid', guid)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function deleteCollection(guid: string) {\n  const { error } = await supabase\n    .from('calendar_collections')\n    .delete()\n    .eq('guid', guid);\n  \n  if (error) throw error;\n  return { success: true };\n}\n```\n\n2. Update API routes to use the service layer:\n\n- `/api/collections.ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getAllCollections, createCollection } from '../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    if (req.method === 'GET') {\n      const collections = await getAllCollections();\n      return res.status(200).json(collections);\n    } else if (req.method === 'POST') {\n      const collection = await createCollection(req.body);\n      return res.status(201).json(collection);\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n- `/api/collections/[guid].ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getCollectionByGuid, updateCollection, deleteCollection } from '../../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { guid } = req.query;\n  \n  if (!guid || Array.isArray(guid)) {\n    return res.status(400).json({ message: 'Invalid guid parameter' });\n  }\n  \n  try {\n    if (req.method === 'GET') {\n      const collection = await getCollectionByGuid(guid);\n      return res.status(200).json(collection);\n    } else if (req.method === 'PUT') {\n      const collection = await updateCollection(guid, req.body);\n      return res.status(200).json(collection);\n    } else if (req.method === 'DELETE') {\n      await deleteCollection(guid);\n      return res.status(204).end();\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n3. Add backward compatibility with existing in-memory storage during transition:\n```typescript\n// In the service layer, add fallback to in-memory storage\nexport async function getAllCollections() {\n  try {\n    const { data, error } = await supabase\n      .from('calendar_collections')\n      .select('*')\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data as CalendarCollection[];\n  } catch (error) {\n    console.warn('Falling back to in-memory storage', error);\n    return globalThis.calendarCollections || [];\n  }\n}\n```",
        "testStrategy": "1. Create unit tests for each service function\n2. Test each API endpoint with valid and invalid requests\n3. Verify error handling for database connection issues\n4. Test backward compatibility with existing API response format\n5. Verify CRUD operations work correctly with Supabase\n6. Test performance and response times compared to in-memory storage\n7. Ensure proper error responses for invalid requests",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Deployment and Documentation Updates",
        "description": "Update deployment process and documentation to include Supabase integration requirements",
        "details": "1. Update README.md with Supabase setup instructions:\n```markdown\n## Supabase Setup\n\n1. Create a Supabase project at https://supabase.com\n2. Create the `calendar_collections` table using the SQL in `schema.sql`\n3. Get your Supabase URL and anon key from the project settings\n4. Add these to your environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n```\n\n2. Create a `schema.sql` file with the table creation SQL:\n```sql\nCREATE TABLE calendar_collections (\n  guid UUID PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  sources JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE INDEX idx_calendar_collections_created_at ON calendar_collections(created_at);\n```\n\n3. Update deployment scripts or configuration:\n   - Add Supabase environment variables to deployment platform (Vercel, Netlify, etc.)\n   - Create a deployment checklist that includes Supabase setup\n\n4. Create a simple health check endpoint to verify Supabase connection:\n```typescript\n// pages/api/health.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { testSupabaseConnection } from '../../lib/supabase';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ message: 'Method not allowed' });\n  }\n\n  try {\n    const connectionStatus = await testSupabaseConnection();\n    return res.status(200).json({\n      status: 'ok',\n      supabase: connectionStatus.success ? 'connected' : 'error',\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error('Health check error:', error);\n    return res.status(500).json({ status: 'error', message: 'Internal server error' });\n  }\n}\n```\n\n5. Add logging for monitoring database operations in production",
        "testStrategy": "1. Verify README.md instructions are clear and complete\n2. Test schema.sql script in a fresh Supabase project\n3. Verify health check endpoint correctly reports connection status\n4. Test deployment process on staging environment\n5. Verify environment variables are correctly set in production\n6. Create a deployment checklist and verify all steps\n7. Test the application after deployment to ensure collections persist",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-20T06:49:44.250Z",
      "updated": "2025-08-20T06:49:58.088Z",
      "description": "Tasks for master context"
    }
  },
  "supabase-backend": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Supabase Database Schema",
        "description": "Design and implement the database schema in Supabase to store calendar collections persistently",
        "details": "1. Create a new table called 'calendar_collections' in Supabase with the following columns:\n   - guid: UUID (primary key)\n   - name: TEXT (not null)\n   - description: TEXT\n   - sources: JSONB (not null)\n   - created_at: TIMESTAMP WITH TIME ZONE (default: now())\n   - updated_at: TIMESTAMP WITH TIME ZONE (default: now())\n\n2. Set up appropriate indexes:\n   - Primary key on guid\n   - Index on created_at for potential sorting/filtering\n\n3. Configure Row Level Security (RLS) policies if needed for future user authentication\n\n4. Create a TypeScript interface that matches the CalendarCollection type but includes the additional database fields:\n\n```typescript\ninterface StoredCalendarCollection extends CalendarCollection {\n  created_at: string;\n  updated_at: string;\n}\n```",
        "testStrategy": "1. Verify table creation in Supabase dashboard\n2. Test inserting a sample record manually through the Supabase interface\n3. Confirm data types are correctly defined, especially the JSONB for sources\n4. Validate that created_at and updated_at fields are automatically populated\n5. Ensure the schema matches the existing CalendarCollection TypeScript type",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Supabase Client Configuration",
        "description": "Set up Supabase client integration with environment variables for the application",
        "details": "1. Install required dependencies:\n```bash\nnpm install @supabase/supabase-js\n```\n\n2. Create a utility file for Supabase client initialization (e.g., `lib/supabase.ts`):\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n\n3. Update environment configuration:\n   - Add the following to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n   - Update `.env.example` to include these variables\n   - Update deployment documentation to include Supabase environment variables\n\n4. Create a simple test function to verify connection:\n```typescript\nexport async function testSupabaseConnection() {\n  try {\n    const { data, error } = await supabase.from('calendar_collections').select('count');\n    if (error) throw error;\n    return { success: true };\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return { success: false, error };\n  }\n}\n```",
        "testStrategy": "1. Create a simple test endpoint that calls testSupabaseConnection()\n2. Verify connection succeeds with valid environment variables\n3. Verify appropriate error handling when environment variables are missing\n4. Test connection in both development and production environments\n5. Ensure environment variables are properly loaded in all environments",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update API Routes for Supabase Integration",
        "description": "Refactor existing API routes to use Supabase for persistent storage instead of in-memory storage",
        "details": "1. Create a service layer for calendar collections (e.g., `services/calendarCollections.ts`):\n```typescript\nimport { supabase } from '../lib/supabase';\nimport { v4 as uuidv4 } from 'uuid';\nimport { CalendarCollection } from '../types';\n\nexport async function getAllCollections() {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .order('created_at', { ascending: false });\n  \n  if (error) throw error;\n  return data as CalendarCollection[];\n}\n\nexport async function getCollectionByGuid(guid: string) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .eq('guid', guid)\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function createCollection(collection: Omit<CalendarCollection, 'guid'>) {\n  const guid = uuidv4();\n  const newCollection = { ...collection, guid };\n  \n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .insert([newCollection])\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function updateCollection(guid: string, updates: Partial<CalendarCollection>) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .update({ ...updates, updated_at: new Date() })\n    .eq('guid', guid)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function deleteCollection(guid: string) {\n  const { error } = await supabase\n    .from('calendar_collections')\n    .delete()\n    .eq('guid', guid);\n  \n  if (error) throw error;\n  return { success: true };\n}\n```\n\n2. Update API routes to use the service layer:\n\n- `/api/collections.ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getAllCollections, createCollection } from '../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    if (req.method === 'GET') {\n      const collections = await getAllCollections();\n      return res.status(200).json(collections);\n    } else if (req.method === 'POST') {\n      const collection = await createCollection(req.body);\n      return res.status(201).json(collection);\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n- `/api/collections/[guid].ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getCollectionByGuid, updateCollection, deleteCollection } from '../../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { guid } = req.query;\n  \n  if (!guid || Array.isArray(guid)) {\n    return res.status(400).json({ message: 'Invalid guid parameter' });\n  }\n  \n  try {\n    if (req.method === 'GET') {\n      const collection = await getCollectionByGuid(guid);\n      return res.status(200).json(collection);\n    } else if (req.method === 'PUT') {\n      const collection = await updateCollection(guid, req.body);\n      return res.status(200).json(collection);\n    } else if (req.method === 'DELETE') {\n      await deleteCollection(guid);\n      return res.status(204).end();\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n3. Add backward compatibility with existing in-memory storage during transition:\n```typescript\n// In the service layer, add fallback to in-memory storage\nexport async function getAllCollections() {\n  try {\n    const { data, error } = await supabase\n      .from('calendar_collections')\n      .select('*')\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data as CalendarCollection[];\n  } catch (error) {\n    console.warn('Falling back to in-memory storage', error);\n    return globalThis.calendarCollections || [];\n  }\n}\n```",
        "testStrategy": "1. Create unit tests for each service function\n2. Test each API endpoint with valid and invalid requests\n3. Verify error handling for database connection issues\n4. Test backward compatibility with existing API response format\n5. Verify CRUD operations work correctly with Supabase\n6. Test performance and response times compared to in-memory storage\n7. Ensure proper error responses for invalid requests",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Deployment and Documentation Updates",
        "description": "Update deployment process and documentation to include Supabase integration requirements",
        "details": "1. Update README.md with Supabase setup instructions:\n```markdown\n## Supabase Setup\n\n1. Create a Supabase project at https://supabase.com\n2. Create the `calendar_collections` table using the SQL in `schema.sql`\n3. Get your Supabase URL and anon key from the project settings\n4. Add these to your environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n```\n\n2. Create a `schema.sql` file with the table creation SQL:\n```sql\nCREATE TABLE calendar_collections (\n  guid UUID PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  sources JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE INDEX idx_calendar_collections_created_at ON calendar_collections(created_at);\n```\n\n3. Update deployment scripts or configuration:\n   - Add Supabase environment variables to deployment platform (Vercel, Netlify, etc.)\n   - Create a deployment checklist that includes Supabase setup\n\n4. Create a simple health check endpoint to verify Supabase connection:\n```typescript\n// pages/api/health.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { testSupabaseConnection } from '../../lib/supabase';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ message: 'Method not allowed' });\n  }\n\n  try {\n    const connectionStatus = await testSupabaseConnection();\n    return res.status(200).json({\n      status: 'ok',\n      supabase: connectionStatus.success ? 'connected' : 'error',\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error('Health check error:', error);\n    return res.status(500).json({ status: 'error', message: 'Internal server error' });\n  }\n}\n```\n\n5. Add logging for monitoring database operations in production",
        "testStrategy": "1. Verify README.md instructions are clear and complete\n2. Test schema.sql script in a fresh Supabase project\n3. Verify health check endpoint correctly reports connection status\n4. Test deployment process on staging environment\n5. Verify environment variables are correctly set in production\n6. Create a deployment checklist and verify all steps\n7. Test the application after deployment to ensure collections persist",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-20T06:50:18.280Z",
      "updated": "2025-08-20T07:10:03.790Z",
      "description": "Implement Supabase backend for persistent calendar GUID storage"
    }
  },
  "dependency-cleanup": {
    "tasks": [
      {
        "id": 1,
        "title": "Remove Unused Radix UI Dependencies",
        "description": "Remove unused Radix UI dependencies and class-variance-authority from package.json to reduce bundle size by approximately 200-400KB.",
        "details": "This task involves removing the following unused dependencies from the project's package.json file:\n\n1. @radix-ui/react-dialog\n2. @radix-ui/react-select\n3. @radix-ui/react-toast\n4. class-variance-authority\n\nSteps to complete this task:\n1. Open the project's package.json file.\n2. Locate the dependencies section.\n3. Remove the entries for the four packages listed above.\n4. Run `npm install` or `yarn` (depending on the package manager used in the project) to update the lock file.\n5. Verify that the packages are no longer listed in the dependencies section of package.json.\n6. Verify that the node_modules folder no longer contains these packages after reinstallation.\n\nNote: Before removing these dependencies, perform a final verification by searching the entire codebase for any imports of these packages to ensure they are truly unused. This can be done using grep or a similar search tool:\n\n```bash\ngrep -r \"@radix-ui/react-dialog\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\ngrep -r \"@radix-ui/react-select\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\ngrep -r \"@radix-ui/react-toast\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\ngrep -r \"class-variance-authority\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\n```\n\nThe expected outcome is a reduction in bundle size by approximately 200-400KB, which should improve application load times and performance.",
        "testStrategy": "To verify that this task has been completed successfully:\n\n1. Check that package.json no longer contains the following dependencies:\n   - @radix-ui/react-dialog\n   - @radix-ui/react-select\n   - @radix-ui/react-toast\n   - class-variance-authority\n\n2. Verify that the package-lock.json or yarn.lock file has been updated accordingly.\n\n3. Run a build of the application and ensure it compiles without errors:\n   ```bash\n   npm run build\n   # or\n   yarn build\n   ```\n\n4. Compare the bundle size before and after the changes to confirm the expected reduction:\n   - Use a tool like `source-map-explorer` or the built-in bundle analyzer if available\n   - Verify that the bundle size has decreased by approximately 200-400KB\n\n5. Run the application and perform basic smoke tests to ensure no functionality has been broken:\n   - Navigate through main application flows\n   - Test any UI components that might have been using these dependencies indirectly\n   - Check the browser console for any unexpected errors\n\n6. Run the existing test suite to ensure all tests still pass:\n   ```bash\n   npm test\n   # or\n   yarn test\n   ```",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Remove Unused Tailwind Plugins",
        "description": "Remove unused Tailwind plugins (@tailwindcss/forms and @tailwindcss/typography) from devDependencies and tailwind.config.ts to reduce bundle size and simplify the configuration.",
        "details": "This task involves removing unused Tailwind CSS plugins that are currently configured but not being utilized in the codebase.\n\nSteps to complete this task:\n1. Open the project's package.json file.\n2. Locate the devDependencies section.\n3. Remove the entries for the following packages:\n   - @tailwindcss/forms\n   - @tailwindcss/typography\n4. Open the tailwind.config.ts file.\n5. Find the plugins array in the configuration.\n6. Remove the references to these plugins. They might look like:\n   ```typescript\n   plugins: [\n     require('@tailwindcss/forms'),\n     require('@tailwindcss/typography'),\n     // other plugins...\n   ],\n   ```\n7. Run `npm install` or `yarn` (depending on the package manager used in the project) to update the lock file.\n8. Rebuild the project to ensure that the Tailwind CSS configuration still works correctly without these plugins.\n9. Verify that no styling issues appear in the UI after removing these plugins, confirming they were indeed unused.\n\nNote: This task is similar to Task #1 in that it involves removing unused dependencies, but focuses specifically on Tailwind CSS plugins rather than Radix UI components.",
        "testStrategy": "To verify that this task has been completed successfully:\n\n1. Check that package.json no longer contains the following devDependencies:\n   - @tailwindcss/forms\n   - @tailwindcss/typography\n\n2. Verify that tailwind.config.ts no longer includes these plugins in its plugins array.\n\n3. Run the following commands to ensure the project builds correctly:\n   ```bash\n   npm install  # or yarn\n   npm run build  # or the appropriate build command for the project\n   ```\n\n4. Inspect the application UI in various states and pages to confirm that:\n   - No console errors related to missing Tailwind plugins appear\n   - All UI elements maintain their expected styling\n   - No form elements or typography elements have lost their styling\n\n5. Verify that the package-lock.json or yarn.lock file has been updated to remove these dependencies.\n\n6. Run Lighthouse or a similar performance tool to confirm that the bundle size has been reduced.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update Dependencies: Remove Unused Testing Library and Audit Axios",
        "description": "Remove @testing-library/user-event from devDependencies since it's not being used in any test files, and audit axios to update it to the latest version for security patches.",
        "details": "This task involves cleaning up unused dependencies and ensuring security by updating a critical package.\n\nSteps to complete this task:\n1. Open the project's package.json file.\n2. Locate the devDependencies section.\n3. Remove the entry for @testing-library/user-event.\n4. Run `npm audit` or `yarn audit` (depending on the package manager used in the project) to check for vulnerabilities in the axios package.\n5. If vulnerabilities are found, update axios to the latest version:\n   - For npm: `npm update axios` or `npm install axios@latest`\n   - For yarn: `yarn upgrade axios` or `yarn add axios@latest`\n6. Run the application and tests to ensure the update doesn't break existing functionality.\n7. Update the package-lock.json or yarn.lock file by running `npm install` or `yarn`.\n8. Document any significant changes in the axios API that might affect the codebase.\n\nConsiderations:\n- Before removing @testing-library/user-event, verify it's truly not used by searching through all test files.\n- Check for any imports like `import userEvent from '@testing-library/user-event'` or similar.\n- When updating axios, review the changelog between the current version and the latest to understand potential breaking changes.\n- If the axios update introduces breaking changes, document them and make necessary adjustments to the codebase.",
        "testStrategy": "To verify that this task has been completed successfully:\n\n1. Check that package.json no longer contains @testing-library/user-event in the devDependencies section:\n   ```\n   grep -r \"@testing-library/user-event\" package.json\n   ```\n   This should return no results.\n\n2. Verify that no test files are importing @testing-library/user-event:\n   ```\n   grep -r \"from '@testing-library/user-event'\" --include=\"*.test.*\" .\n   grep -r \"from \\\"@testing-library/user-event\\\"\" --include=\"*.test.*\" .\n   ```\n   Both commands should return no results.\n\n3. Confirm axios has been updated to the latest version:\n   ```\n   npm list axios\n   ```\n   or\n   ```\n   yarn why axios\n   ```\n   The output should show the latest version available.\n\n4. Run the application's test suite to ensure all tests pass:\n   ```\n   npm test\n   ```\n   or\n   ```\n   yarn test\n   ```\n\n5. Run a security audit to verify no vulnerabilities remain:\n   ```\n   npm audit\n   ```\n   or\n   ```\n   yarn audit\n   ```\n   There should be no high or critical vulnerabilities related to axios.\n\n6. Manually test any features that rely on axios to ensure they still function correctly after the update.",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:37.719Z",
      "updated": "2025-08-22T09:38:44.798Z",
      "description": "Remove unused dependencies and optimize package.json"
    }
  },
  "code-deduplication": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Shared HTTP Client Utility for Calendar Operations",
        "description": "Develop a centralized HTTP client utility that consolidates duplicate axios configurations currently spread across calendar-utils.ts and calendar-fetcher.ts, including common timeout settings, User-Agent headers, and error handling patterns.",
        "details": "1. Create a new file named `http-client.ts` in an appropriate utilities or shared directory.\n\n2. Implement a configurable axios instance with the following features:\n   - Default timeout configuration (likely matching the current timeout in both files)\n   - Standard User-Agent headers\n   - Consistent error handling middleware\n   - Optional request/response interceptors\n   - Typed response handling\n\n3. Example implementation:\n```typescript\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';\n\n// Default configuration\nconst DEFAULT_TIMEOUT = 30000; // or whatever the current timeout is\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'YourAppName/1.0', // match existing User-Agent\n  'Content-Type': 'application/json'\n};\n\n// Error handling types\nexport interface ErrorResponse {\n  message: string;\n  code?: string;\n  details?: any;\n}\n\n// Create the HTTP client factory\nexport function createHttpClient(config: AxiosRequestConfig = {}): AxiosInstance {\n  const instance = axios.create({\n    timeout: DEFAULT_TIMEOUT,\n    headers: DEFAULT_HEADERS,\n    ...config\n  });\n\n  // Add request interceptor\n  instance.interceptors.request.use(\n    (config) => {\n      // Any request preprocessing\n      return config;\n    },\n    (error) => Promise.reject(error)\n  );\n\n  // Add response interceptor with standardized error handling\n  instance.interceptors.response.use(\n    (response) => response,\n    (error: AxiosError) => {\n      const errorResponse: ErrorResponse = {\n        message: 'An error occurred during the request',\n        details: error.response?.data\n      };\n      \n      if (error.response) {\n        errorResponse.code = `HTTP_${error.response.status}`;\n      } else if (error.request) {\n        errorResponse.code = 'NETWORK_ERROR';\n      } else {\n        errorResponse.code = 'REQUEST_SETUP_ERROR';\n      }\n      \n      return Promise.reject(errorResponse);\n    }\n  );\n\n  return instance;\n}\n\n// Export a default instance for common use\nexport const httpClient = createHttpClient();\n\n// Calendar-specific client with any special configurations\nexport const calendarHttpClient = createHttpClient({\n  // Any calendar-specific defaults\n});\n```\n\n4. Refactor calendar-utils.ts and calendar-fetcher.ts to use the new shared HTTP client:\n   - Import the appropriate client (default or calendar-specific)\n   - Replace direct axios calls with the new client\n   - Remove duplicate configuration code\n   - Ensure error handling is consistent with the new pattern\n\n5. Consider adding additional utility methods specific to calendar operations if needed.",
        "testStrategy": "1. Unit Tests:\n   - Create unit tests for the HTTP client utility using Jest or your project's testing framework\n   - Test the default configuration is applied correctly\n   - Mock axios responses to verify error handling works as expected\n   - Test that custom configurations properly override defaults\n   - Verify interceptors are properly applied\n\n2. Integration Tests:\n   - Create tests that verify calendar-utils.ts and calendar-fetcher.ts work correctly with the new client\n   - Test actual API calls to ensure timeout, headers, and error handling work in real scenarios\n   - Compare responses between old implementation and new implementation to ensure they match\n\n3. Error Handling Tests:\n   - Simulate network errors, timeout errors, and server errors to verify proper error handling\n   - Verify error objects contain the expected properties and formats\n   - Test error logging functionality if applicable\n\n4. Code Review Verification:\n   - Verify that all instances of axios in the calendar files have been replaced with the new client\n   - Confirm that no duplicate configuration exists across the files\n   - Check that the error handling is consistent\n\n5. Performance Testing:\n   - Verify that the refactored code doesn't introduce any performance regressions\n   - Test response times for typical calendar operations",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Extract Global Storage Management into Shared Module",
        "description": "Create a centralized utility module that consolidates duplicate storage initialization functions and global variable declarations currently spread across multiple API route files.",
        "details": "1. Create a new file named `storage-manager.ts` in the utilities or shared directory.\n\n2. Identify and extract the common storage initialization patterns from the 4+ API route files:\n   - Global variable declarations\n   - The `initializeStorage()` function\n   - Any related helper functions or type definitions\n\n3. Implement a clean API for the storage module:\n```typescript\n// storage-manager.ts\nimport { Storage } from '@google-cloud/storage'; // or whatever storage library is being used\n\n// Singleton instance\nlet storageInstance: Storage | null = null;\n\n// Configuration interface\nexport interface StorageConfig {\n  projectId?: string;\n  keyFilename?: string;\n  // Add other relevant configuration options\n}\n\n/**\n * Initialize and return a storage instance\n * @param config Optional configuration to override defaults\n * @returns Configured Storage instance\n */\nexport function getStorageInstance(config: StorageConfig = {}): Storage {\n  if (!storageInstance) {\n    storageInstance = new Storage({\n      // Default configuration\n      ...config\n    });\n  }\n  return storageInstance;\n}\n\n/**\n * Reset the storage instance (primarily for testing)\n */\nexport function resetStorageInstance(): void {\n  storageInstance = null;\n}\n\n// Export any other utility functions related to storage management\n```\n\n4. Update all API route files to import and use the new shared module:\n   - Replace local storage initialization with imports from the new module\n   - Remove duplicate code\n   - Ensure consistent configuration across all routes\n\n5. Consider adding additional utility functions that might be useful across routes:\n   - File upload helpers\n   - Common bucket operations\n   - Error handling specific to storage operations",
        "testStrategy": "1. Unit Tests:\n   - Create unit tests for the storage manager module using Jest or your project's testing framework\n   - Test the singleton pattern works correctly (multiple calls return the same instance)\n   - Test that configuration options properly override defaults\n   - Test the reset functionality works as expected\n   - Mock the storage library to verify interactions\n\n2. Integration Tests:\n   - Verify that all API routes that previously used local storage initialization now correctly use the shared module\n   - Test with a test bucket to ensure actual storage operations still work correctly\n   - Verify error handling works consistently across all routes\n\n3. Manual Testing:\n   - Execute each API endpoint that uses storage functionality to verify it still works correctly\n   - Check logs to ensure no duplicate initialization is occurring\n   - Verify performance is maintained or improved\n\n4. Code Review:\n   - Ensure all duplicate code has been removed from API route files\n   - Verify consistent usage patterns across the codebase",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create API Response Utilities for Standardized Error and Success Handling",
        "description": "Develop a centralized utility module that standardizes API response formats for both success and error cases, eliminating duplicate error handling patterns across API routes.",
        "details": "1. Create a new file named `api-response.ts` in the utilities or shared directory.\n\n2. Define standardized response interfaces:\n```typescript\nexport interface ApiSuccessResponse<T> {\n  success: true;\n  data: T;\n  message?: string;\n}\n\nexport interface ApiErrorResponse {\n  success: false;\n  error: {\n    code: string;\n    message: string;\n    details?: any;\n  };\n  statusCode: number;\n}\n\nexport type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;\n```\n\n3. Implement utility functions for creating consistent responses:\n```typescript\nexport const createSuccessResponse = <T>(data: T, message?: string): ApiSuccessResponse<T> => ({\n  success: true,\n  data,\n  message\n});\n\nexport const createErrorResponse = (\n  message: string,\n  statusCode: number = 500,\n  code: string = 'INTERNAL_ERROR',\n  details?: any\n): ApiErrorResponse => ({\n  success: false,\n  error: {\n    code,\n    message,\n    details\n  },\n  statusCode\n});\n\n// Common error factory functions\nexport const notFoundError = (resource: string) => \n  createErrorResponse(`${resource} not found`, 404, 'NOT_FOUND');\n\nexport const fetchFailedError = (resource: string, details?: any) => \n  createErrorResponse(`Failed to fetch ${resource}`, 500, 'FETCH_FAILED', details);\n\n// Additional common error patterns as needed\n```\n\n4. Create Express middleware for consistent error handling:\n```typescript\nimport { Request, Response, NextFunction } from 'express';\n\nexport const errorHandler = (\n  err: any,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  console.error('API Error:', err);\n  \n  // Handle known error types\n  if (err.name === 'NotFoundError') {\n    return res.status(404).json(notFoundError(err.resource || 'Resource'));\n  }\n  \n  // Default error response\n  const statusCode = err.statusCode || 500;\n  const errorResponse = createErrorResponse(\n    err.message || 'An unexpected error occurred',\n    statusCode,\n    err.code || 'INTERNAL_ERROR',\n    process.env.NODE_ENV === 'development' ? err.stack : undefined\n  );\n  \n  res.status(statusCode).json(errorResponse);\n};\n```\n\n5. Update existing API routes to use the new utility:\n   - Identify all routes with duplicate error handling patterns\n   - Replace custom error responses with the standardized utility functions\n   - Ensure consistent status codes are used across the application\n\n6. Document the new response format for API consumers, including:\n   - Expected response structure for success and error cases\n   - Common error codes and their meanings\n   - HTTP status code usage",
        "testStrategy": "1. Unit Tests:\n   - Create comprehensive unit tests for the API response utility functions\n   - Test all success response scenarios with various data types\n   - Test all error response scenarios with different status codes and messages\n   - Verify that error factory functions generate the correct format\n   - Test the error middleware with various error types\n\n2. Integration Tests:\n   - Create tests that verify API endpoints return the standardized response format\n   - Test both success and error scenarios for each endpoint\n   - Verify that error responses maintain consistency across different error conditions\n   - Test that status codes are appropriate for the error types\n\n3. Documentation Testing:\n   - Verify that the API documentation accurately reflects the new response format\n   - Create examples of success and error responses for documentation\n   - Ensure error codes are well-documented with clear explanations\n\n4. Manual Testing:\n   - Use API testing tools like Postman to verify response formats\n   - Test edge cases such as empty responses, large payloads, and unusual error conditions\n   - Verify that client applications can properly parse and handle the standardized responses\n\n5. Regression Testing:\n   - Ensure that existing functionality continues to work after implementing the standardized responses\n   - Verify that client applications expecting the old format are not broken (if backward compatibility is required)",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Consolidate Supabase Operations with Shared Database Utilities",
        "description": "Create a centralized database utility module that consolidates duplicate Supabase operations, fallback logic, and data transformation patterns currently spread across multiple collection endpoints.",
        "details": "1. Create a new file named `supabase-utils.ts` in the utilities or shared directory.\n\n2. Identify and extract common Supabase operation patterns from collection endpoints:\n   - Connection initialization and configuration\n   - Error handling and fallback logic\n   - Data transformation between DB format and app format\n   - Query building patterns\n   - Pagination handling\n\n3. Implement a clean API for the Supabase utilities module:\n```typescript\n// supabase-utils.ts\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { DB_TABLES } from './constants';\n\n// Types for database models and app models\nexport interface DBModel {\n  // Common database fields\n  id: string;\n  created_at: string;\n  updated_at: string;\n  // Other common fields\n}\n\nexport interface AppModel {\n  // Common app model fields\n  id: string;\n  createdAt: Date;\n  updatedAt: Date;\n  // Other common fields\n}\n\n// Singleton pattern for Supabase client\nlet supabaseClient: SupabaseClient | null = null;\n\nexport function getSupabaseClient(): SupabaseClient {\n  if (!supabaseClient) {\n    supabaseClient = createClient(\n      process.env.SUPABASE_URL || '',\n      process.env.SUPABASE_KEY || ''\n    );\n  }\n  return supabaseClient;\n}\n\n// Generic data transformation utilities\nexport function transformDBToAppFormat<T extends DBModel, U extends AppModel>(dbModel: T): U {\n  // Implement common transformation logic\n  const appModel = {\n    id: dbModel.id,\n    createdAt: new Date(dbModel.created_at),\n    updatedAt: new Date(dbModel.updated_at),\n    // Transform other fields as needed\n  } as unknown as U;\n  \n  return appModel;\n}\n\nexport function transformAppToDBFormat<T extends AppModel, U extends DBModel>(appModel: T): U {\n  // Implement common transformation logic\n  const dbModel = {\n    id: appModel.id,\n    // Transform other fields as needed\n  } as unknown as U;\n  \n  return dbModel;\n}\n\n// Generic CRUD operations with fallback handling\nexport async function fetchCollection<T>(\n  tableName: string,\n  query: any = {},\n  options: { transformResult?: boolean } = { transformResult: true }\n): Promise<T[]> {\n  try {\n    const supabase = getSupabaseClient();\n    let queryBuilder = supabase.from(tableName).select('*');\n    \n    // Apply filters from query object\n    if (query.filters) {\n      // Apply filters to queryBuilder\n    }\n    \n    // Apply pagination\n    if (query.pagination) {\n      queryBuilder = queryBuilder\n        .range(query.pagination.start, query.pagination.end);\n    }\n    \n    // Apply sorting\n    if (query.sort) {\n      queryBuilder = queryBuilder.order(query.sort.field, {\n        ascending: query.sort.ascending\n      });\n    }\n    \n    const { data, error } = await queryBuilder;\n    \n    if (error) throw error;\n    \n    return options.transformResult \n      ? data.map(item => transformDBToAppFormat(item))\n      : data;\n  } catch (error) {\n    console.error(`Error fetching from ${tableName}:`, error);\n    // Implement fallback logic here\n    return [];\n  }\n}\n\n// Add other common operations: insert, update, delete, etc.\n```\n\n4. Refactor existing collection endpoints to use the new utilities:\n   - Identify all files that contain Supabase operations\n   - Replace direct Supabase calls with the new utility functions\n   - Ensure consistent error handling across all endpoints\n   - Update any collection-specific transformations to extend the base transformations\n\n5. Add specialized utilities for specific collections as needed, while maintaining the common pattern.\n\n6. Update documentation to reflect the new centralized approach to database operations.",
        "testStrategy": "1. Unit Tests:\n   - Create comprehensive unit tests for the Supabase utility functions using Jest or your project's testing framework\n   - Test the singleton pattern for the Supabase client\n   - Test data transformation functions with various input formats\n   - Mock Supabase responses to test error handling and fallback logic\n   - Test query building with different filter combinations\n   - Verify pagination and sorting functionality\n\n2. Integration Tests:\n   - Test the integration between the utility module and actual Supabase instances\n   - Verify that all CRUD operations work correctly with test data\n   - Test edge cases like empty results, large result sets, and malformed data\n   - Ensure fallback mechanisms work as expected when Supabase is unavailable\n\n3. Refactoring Verification:\n   - Create a checklist of all files that were modified to use the new utilities\n   - Verify each endpoint still returns the same data structure after refactoring\n   - Compare response times before and after refactoring to ensure performance is maintained or improved\n   - Check that error handling is consistent across all refactored endpoints\n\n4. End-to-End Tests:\n   - Update or create E2E tests that exercise the collection endpoints\n   - Verify that the application behaves identically after the refactoring\n   - Test the system's resilience when database operations fail",
        "status": "done",
        "dependencies": [
          1,
          3
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:42.616Z",
      "updated": "2025-08-22T23:45:20.355Z",
      "description": "Consolidate duplicate code patterns and utilities"
    }
  },
  "dead-code-removal": {
    "tasks": [
      {
        "id": 1,
        "title": "Remove Legacy Calendar API Routes",
        "description": "Remove deprecated API routes that use the old globalThis.calendars system which have been replaced by the GUID-based collections system.",
        "details": "This task involves removing the following legacy API routes:\n\n1. `/api/calendars/route.ts`\n2. `/api/calendars/[id]/route.ts`\n3. `/api/calendars/[id]/test/route.ts`\n4. `/api/sync/route.ts`\n\nImplementation steps:\n1. Verify that these routes are no longer referenced in the codebase by performing a comprehensive search for any imports or calls to these endpoints.\n2. Check for any client-side code that might be making fetch requests to these endpoints.\n3. Ensure that the GUID-based collections system fully replaces the functionality of these routes.\n4. Remove the route files from the project.\n5. Update any relevant documentation to reflect the removal of these endpoints.\n6. If there are any tests specifically for these routes, either remove them or update them to test the new GUID-based system instead.\n7. Update API documentation or OpenAPI specs if they exist to remove references to these deprecated endpoints.\n\nNote: Before deletion, it may be helpful to review the implementation of these routes to ensure all functionality has been properly migrated to the new system.",
        "testStrategy": "1. Verify removal of files:\n   - Confirm that `/api/calendars/route.ts`, `/api/calendars/[id]/route.ts`, `/api/calendars/[id]/test/route.ts`, and `/api/sync/route.ts` have been deleted from the codebase.\n\n2. Verify no references remain:\n   - Run a project-wide search for any imports or references to these routes.\n   - Check for any fetch calls or API requests to these endpoints.\n\n3. Functional testing:\n   - Test the GUID-based collections system to ensure it properly handles all the functionality that was previously managed by the removed routes.\n   - Verify that calendar data can still be created, read, updated, and deleted through the new system.\n   - Test calendar synchronization to ensure it works correctly with the new implementation.\n\n4. Regression testing:\n   - Run the existing test suite to ensure no functionality has been broken by the removal.\n   - Check that the application builds successfully without errors.\n\n5. API documentation verification:\n   - Ensure API documentation has been updated to remove references to these deprecated endpoints.\n   - Confirm that new endpoints are properly documented.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Update or Remove Outdated Test File for Homepage",
        "description": "Fix or remove the outdated test file src/__tests__/example.test.tsx which contains tests for non-existent components and expects \"Development Dashboard\" instead of \"Calendar Aggregator\" on the homepage.",
        "details": "This task involves addressing issues with an outdated test file that no longer matches the current application state:\n\n1. First, examine the test file at `src/__tests__/example.test.tsx` to understand what it's testing and how it's structured.\n\n2. Determine whether the test should be:\n   - Updated to match current application behavior\n   - Removed entirely if it's testing deprecated functionality\n\n3. If updating:\n   - Replace expectations for \"Development Dashboard\" with \"Calendar Aggregator\"\n   - Update or remove tests for non-existent components\n   - Ensure imports reference valid components\n   - Adjust test selectors to match current DOM structure\n   - Update any mocks or fixtures to reflect current data structures\n\n4. If removing:\n   - Check if any other tests depend on this file\n   - Ensure removal won't affect test coverage metrics significantly\n   - Document the removal in PR comments\n\n5. Consider adding new tests that properly validate the current homepage functionality if appropriate.\n\n6. Update any related documentation that might reference this test file.\n\nImplementation considerations:\n- Use React Testing Library best practices for any updated tests\n- Focus on testing behavior rather than implementation details\n- Ensure tests are resilient to minor UI changes",
        "testStrategy": "1. If updating the test:\n   - Run the updated test file in isolation: `npm test -- src/__tests__/example.test.tsx`\n   - Verify all tests pass with the new expectations\n   - Ensure test coverage remains the same or improves\n   - Run the full test suite to confirm no regressions\n\n2. If removing the test:\n   - After removal, run the full test suite to verify no other tests were dependent on it\n   - Check test coverage reports to understand impact on overall coverage\n   - Document the removal decision and rationale\n\n3. Manual verification:\n   - Open the homepage and confirm it displays \"Calendar Aggregator\" as expected\n   - Verify any components being tested actually exist in the current implementation\n   - Compare test expectations with actual UI behavior\n\n4. Code review:\n   - Have another developer review the changes to confirm the approach (update vs. remove)\n   - Ensure PR description clearly explains the rationale for the chosen approach",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Remove Obsolete Documentation Files",
        "description": "Remove outdated planning documentation files that describe features which have already been implemented and are no longer needed in the codebase.",
        "details": "This task involves removing the following obsolete documentation files from the repository:\n\n1. `docs/GUID_WORKFLOW_PLAN.md` - Contains planning information for the GUID-based collections system that has now been implemented.\n2. `docs/IMPLEMENTATION_PLAN.md` - Contains outdated implementation plans for features that are now complete.\n3. `PROJECT_GUIDE.md` - Contains project planning information that is no longer relevant.\n\nImplementation steps:\n1. Verify that these documentation files are truly obsolete by:\n   - Confirming that all features described in these documents have been fully implemented\n   - Checking if any ongoing development still references these documents\n   - Ensuring that no current tasks depend on information in these files\n\n2. Before deletion, consider if any content from these files should be:\n   - Archived elsewhere for historical reference\n   - Migrated to current documentation\n   - Preserved in release notes or changelogs\n\n3. Remove the files using git:\n   ```bash\n   git rm docs/GUID_WORKFLOW_PLAN.md\n   git rm docs/IMPLEMENTATION_PLAN.md\n   git rm PROJECT_GUIDE.md\n   ```\n\n4. Update any references to these files in:\n   - README.md or other documentation\n   - Contributing guidelines\n   - Developer onboarding materials\n\n5. Commit the changes with a clear message explaining the removal:\n   ```bash\n   git commit -m \"Remove obsolete documentation files as features are now implemented\"\n   ```",
        "testStrategy": "1. Verify file removal:\n   - Confirm that `docs/GUID_WORKFLOW_PLAN.md`, `docs/IMPLEMENTATION_PLAN.md`, and `PROJECT_GUIDE.md` have been deleted from the repository\n   - Verify these files no longer appear in the project directory structure\n\n2. Check for broken references:\n   - Run a project-wide search for any references to the removed files:\n     ```bash\n     grep -r \"GUID_WORKFLOW_PLAN.md\" .\n     grep -r \"IMPLEMENTATION_PLAN.md\" .\n     grep -r \"PROJECT_GUIDE.md\" .\n     ```\n   - Ensure any links to these files in other documentation have been updated or removed\n\n3. Verify documentation completeness:\n   - Confirm that any critical information from the removed files has been preserved in current documentation if needed\n   - Check that developers can still find necessary information without these files\n\n4. Repository validation:\n   - Run any documentation validation tools or linters to ensure no broken links remain\n   - Verify that the project builds correctly without these files",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Remove Unused Calendar Utility Functions",
        "description": "Remove unused functions from calendar-related utility files including isValidICalUrl(), combineICalFeedsFromParsedEvents(), and evaluate if fetchCalendarEvents() should remain as a public API.",
        "details": "This task involves removing unused functions from calendar utility files to improve code maintainability and reduce technical debt:\n\n1. Remove `isValidICalUrl()` function from `calendar-utils.ts`:\n   - Locate the function in the file\n   - Check for any imports or references to this function throughout the codebase\n   - If no references exist, remove the function entirely\n   - If references exist, document them for further evaluation\n   - Update any exports that might include this function\n\n2. Remove `combineICalFeedsFromParsedEvents()` function from `ical-combiner.ts`:\n   - Locate the function in the file\n   - Check for any imports or references to this function throughout the codebase\n   - If no references exist, remove the function entirely\n   - If references exist, document them for further evaluation\n   - Update any exports that might include this function\n\n3. Evaluate `fetchCalendarEvents()` in `calendar-fetcher.ts`:\n   - Determine if this function is being used anywhere in the codebase\n   - If it's not used, remove it entirely\n   - If it is used but should not be public, consider:\n     - Moving it to a more appropriate location\n     - Making it a private function (if the language supports it)\n     - Documenting why it remains if it needs to stay\n\n4. Update any related documentation or comments that reference these functions\n\n5. Ensure that removing these functions doesn't break any type definitions or interfaces\n\n6. Consider updating unit tests that might be testing these functions:\n   - Remove tests for functions that are being removed\n   - Update tests that might indirectly use these functions",
        "testStrategy": "1. Static code analysis:\n   - Run a linter to ensure no syntax errors were introduced\n   - Run TypeScript compiler to verify no type errors were introduced\n\n2. Verify function removal:\n   - Confirm that `isValidICalUrl()` has been removed from `calendar-utils.ts`\n   - Confirm that `combineICalFeedsFromParsedEvents()` has been removed from `ical-combiner.ts`\n   - Verify that `fetchCalendarEvents()` has either been removed or properly documented if kept\n\n3. Test for broken references:\n   - Run a project-wide search for any remaining references to the removed functions\n   - Ensure no imports are attempting to import the removed functions\n\n4. Run existing tests:\n   - Run the test suite to ensure that removing these functions hasn't broken any existing functionality\n   - Pay special attention to calendar-related tests\n\n5. Manual testing:\n   - Test calendar-related functionality in the application to ensure everything still works as expected\n   - Verify that calendar data is still properly fetched, combined, and displayed\n\n6. Code review:\n   - Have another developer review the changes to ensure nothing important was accidentally removed",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:47.850Z",
      "updated": "2025-08-22T10:15:39.790Z",
      "description": "Remove obsolete API routes, unused functions, and outdated files"
    }
  },
  "config-optimization": {
    "tasks": [
      {
        "id": 1,
        "title": "Optimize Tailwind Configuration",
        "description": "Remove unused Tailwind plugins, reduce the safelist, and clean up color definitions to improve build performance and reduce CSS bundle size.",
        "details": "This task involves optimizing the Tailwind CSS configuration to improve build performance and reduce bundle size:\n\n1. Remove unused plugins:\n   - Remove `@tailwindcss/forms` plugin from the Tailwind config\n   - Remove `@tailwindcss/typography` plugin from the Tailwind config\n   - Uninstall these packages from package.json if they're no longer needed elsewhere\n\n2. Optimize the safelist:\n   - Review the current safelist with 49 classes\n   - Determine which classes are actually needed for dynamic content\n   - Remove unnecessary classes from the safelist\n   - Consider using regex patterns for dynamic class names instead of listing each variant\n\n3. Clean up color definitions:\n   - Review the color palette in the Tailwind config\n   - Remove unused color definitions\n   - Ensure the theme is consistent with the design system\n   - Remember that Tailwind automatically scans content for used classes\n\n4. Update the tailwind.config.js file with these changes:\n```javascript\n// Before\nmodule.exports = {\n  // ... other config\n  plugins: [\n    require('@tailwindcss/forms'),\n    require('@tailwindcss/typography'),\n    // ... other plugins\n  ],\n  safelist: [\n    // 49 classes listed here\n  ],\n  theme: {\n    colors: {\n      // Extensive color definitions\n    }\n  }\n}\n\n// After\nmodule.exports = {\n  // ... other config\n  plugins: [\n    // Only necessary plugins\n  ],\n  safelist: [\n    // Only essential classes or regex patterns\n  ],\n  theme: {\n    colors: {\n      // Streamlined color definitions\n    }\n  }\n}\n```\n\n5. Rebuild the project to ensure everything works correctly after these changes.",
        "testStrategy": "1. Compare build times before and after the optimization:\n   - Run `npm run build` (or equivalent) before making changes and record the time\n   - Run the same build command after changes and verify improved build time\n\n2. Compare CSS bundle size:\n   - Measure the size of the CSS output file before changes\n   - Measure the size after changes and confirm reduction\n\n3. Visual regression testing:\n   - Take screenshots of key pages before changes\n   - Compare with screenshots after changes to ensure no visual regressions\n\n4. Functional testing:\n   - Test all dynamic components that might use classes from the safelist\n   - Verify that dynamically generated classes still work correctly\n   - Test responsive layouts and interactive elements\n\n5. Browser compatibility:\n   - Test in Chrome, Firefox, Safari, and Edge to ensure cross-browser compatibility\n\n6. Run the application's test suite to ensure no functionality is broken\n\n7. Code review:\n   - Have another developer review the changes to ensure no critical classes were removed",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Clean Up globals.css File",
        "description": "Refactor the globals.css file by removing redundant CSS utilities that duplicate Tailwind classes, consolidating glass effect patterns, and eliminating custom responsive classes that replicate Tailwind's native functionality.",
        "details": "This task involves cleaning up the globals.css file to reduce duplication and improve maintainability:\n\n1. Remove redundant CSS utilities:\n   - Identify and remove any custom utility classes that duplicate existing Tailwind classes\n   - Look for properties like margins, paddings, colors, and flexbox utilities that Tailwind already provides\n   - Document each removed class with a comment indicating the Tailwind equivalent\n\n2. Consolidate glass effect patterns:\n   - Identify all instances of glass/frosted glass effect CSS\n   - Create a single, reusable glass effect utility class\n   - Replace all duplicated implementations with the new consolidated class\n   - Consider creating a Tailwind component using @apply if the effect is used frequently\n\n3. Remove custom responsive classes:\n   - Identify custom media query classes like .md-grid-cols-2\n   - Replace them with Tailwind's native responsive variants (e.g., md:grid-cols-2)\n   - Update all component files that use these custom classes to use Tailwind's responsive syntax instead\n\n4. Document changes:\n   - Create a brief documentation section at the top of globals.css explaining the refactoring\n   - List any custom utilities that were kept and why they're still necessary\n\n5. Verify no visual regressions:\n   - Test all affected components across different screen sizes\n   - Ensure the application's appearance remains consistent after changes",
        "testStrategy": "1. Visual regression testing:\n   - Take screenshots of key pages before making changes\n   - Compare with screenshots after changes to ensure visual consistency\n   - Test on multiple screen sizes (mobile, tablet, desktop)\n\n2. CSS bundle size verification:\n   - Measure the size of the CSS bundle before and after changes\n   - Verify a reduction in file size after removing redundant code\n\n3. Browser compatibility testing:\n   - Test the changes in Chrome, Firefox, Safari, and Edge\n   - Ensure the glass effects and responsive behaviors work consistently across browsers\n\n4. Code review checklist:\n   - Verify all removed CSS classes are actually redundant with Tailwind\n   - Confirm all components using custom responsive classes have been updated\n   - Check that the consolidated glass effect works in all instances where it's used\n\n5. Performance testing:\n   - Compare page load times before and after changes\n   - Verify that CSS parsing time has improved",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Fix Configuration Files and Module Settings",
        "description": "Remove or properly configure builder.config.json, fix Husky setup by implementing pre-commit hooks or removing the prepare script, and add 'type: module' to package.json to resolve build warnings.",
        "details": "This task involves addressing several configuration issues in the project:\n\n1. Builder.config.json:\n   - Evaluate if builder.config.json is needed for the project\n   - If not needed, remove the file completely\n   - If needed, properly configure it according to the third-party builder tool documentation\n   - Update any related import statements or references in the codebase\n\n2. Fix Husky setup:\n   - Examine the current Husky configuration in package.json (look for \"prepare\" script)\n   - Option A: Properly implement pre-commit hooks\n     - Ensure Husky is correctly installed: `npm install husky --save-dev`\n     - Set up proper pre-commit hooks: `npx husky add .husky/pre-commit \"npm test\"`\n     - Configure hooks to run linting, formatting, or tests before commits\n     - Update the prepare script to: `\"prepare\": \"husky install\"`\n   - Option B: Remove Husky completely\n     - Remove the prepare script from package.json\n     - Uninstall Husky: `npm uninstall husky`\n     - Remove any .husky directory and configuration files\n\n3. Add module type to package.json:\n   - Open package.json\n   - Add `\"type\": \"module\"` to the root level of the JSON object\n   - This will enable ES modules syntax throughout the project\n   - Ensure this change doesn't break existing imports (may need to update some import statements)\n\n4. Test the changes to ensure the build process works correctly without warnings.",
        "testStrategy": "1. Builder.config.json verification:\n   - If removed: Build the project and verify no errors related to missing builder configuration\n   - If configured: Build the project and verify the third-party builder tool works as expected\n   - Check logs for any related warnings or errors\n\n2. Husky setup verification:\n   - If implemented: Make a test commit with intentionally failing tests or lint errors\n   - Verify that the pre-commit hook blocks the commit when tests/lint fail\n   - Fix the intentional errors and verify the commit succeeds\n   - If removed: Verify that commits can be made without Husky-related errors\n\n3. Module type verification:\n   - Run `npm run build` and verify no module-related warnings appear\n   - Test importing modules in different files using ES module syntax\n   - Verify that any dynamic imports still function correctly\n   - Check for any runtime errors related to module resolution\n\n4. Overall build verification:\n   - Run a complete build process\n   - Verify that no configuration-related warnings or errors appear\n   - Compare build time and output size before and after changes to ensure no regression",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:53.003Z",
      "updated": "2025-08-22T23:44:55.313Z",
      "description": "Optimize build configurations and remove unused settings"
    }
  },
  "database-implementation": {
    "tasks": [
      {
        "id": 1,
        "title": "Create and apply Supabase database schema for calendar collections",
        "description": "Migrate from in-memory globalThis.calendarCollections storage to a persistent Supabase database schema with proper tables, indexes, and RLS policies for calendar collection management.",
        "details": "Create a comprehensive database schema for calendar collections in Supabase:\n\n1. **Collections Table Structure**:\n   - `id`: UUID primary key with default gen_random_uuid()\n   - `guid`: Text unique not null (for backward compatibility with existing GUID system)\n   - `name`: Text not null\n   - `description`: Text nullable\n   - `calendar_sources`: JSONB array containing calendar source objects with url, name, color, enabled fields\n   - `created_at`: Timestamptz with default now()\n   - `updated_at`: Timestamptz with default now() and automatic update trigger\n   - `user_id`: UUID references auth.users(id) on delete cascade (for future user association)\n   - `is_public`: Boolean default false (for future sharing features)\n   - `metadata`: JSONB nullable (for extensibility)\n\n2. **Indexes for Performance**:\n   - Unique index on `guid` for fast lookups\n   - Index on `user_id` for user-specific queries\n   - Index on `created_at` for sorting\n   - GIN index on `calendar_sources` for JSONB queries\n\n3. **Row Level Security (RLS)**:\n   - Enable RLS on the collections table\n   - Policy for anonymous read access to public collections\n   - Policy for authenticated users to CRUD their own collections\n   - Policy for service role to bypass RLS for admin operations\n\n4. **Database Functions**:\n   - Trigger function to automatically update `updated_at` timestamp\n   - Function to validate calendar_sources JSONB structure\n\n5. **Migration Implementation**:\n   ```sql\n   -- Create collections table\n   CREATE TABLE IF NOT EXISTS public.calendar_collections (\n     id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n     guid TEXT UNIQUE NOT NULL,\n     name TEXT NOT NULL,\n     description TEXT,\n     calendar_sources JSONB NOT NULL DEFAULT '[]'::jsonb,\n     created_at TIMESTAMPTZ DEFAULT NOW(),\n     updated_at TIMESTAMPTZ DEFAULT NOW(),\n     user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n     is_public BOOLEAN DEFAULT FALSE,\n     metadata JSONB,\n     CONSTRAINT valid_calendar_sources CHECK (jsonb_typeof(calendar_sources) = 'array')\n   );\n\n   -- Create indexes\n   CREATE INDEX idx_collections_guid ON public.calendar_collections(guid);\n   CREATE INDEX idx_collections_user_id ON public.calendar_collections(user_id);\n   CREATE INDEX idx_collections_created_at ON public.calendar_collections(created_at DESC);\n   CREATE INDEX idx_collections_calendar_sources ON public.calendar_collections USING GIN(calendar_sources);\n\n   -- Enable RLS\n   ALTER TABLE public.calendar_collections ENABLE ROW LEVEL SECURITY;\n\n   -- RLS Policies\n   CREATE POLICY \"Public collections are viewable by everyone\"\n     ON public.calendar_collections FOR SELECT\n     USING (is_public = true);\n\n   CREATE POLICY \"Users can CRUD their own collections\"\n     ON public.calendar_collections FOR ALL\n     USING (auth.uid() = user_id)\n     WITH CHECK (auth.uid() = user_id);\n\n   -- Update trigger\n   CREATE OR REPLACE FUNCTION update_updated_at_column()\n   RETURNS TRIGGER AS $$\n   BEGIN\n     NEW.updated_at = NOW();\n     RETURN NEW;\n   END;\n   $$ LANGUAGE plpgsql;\n\n   CREATE TRIGGER update_collections_updated_at\n     BEFORE UPDATE ON public.calendar_collections\n     FOR EACH ROW\n     EXECUTE FUNCTION update_updated_at_column();\n   ```\n\n6. **Apply using Supabase MCP tools**:\n   - Use `mcp__supabase__apply_migration` to apply the schema\n   - Verify with `mcp__supabase__list_tables` and `mcp__supabase__execute_sql`",
        "testStrategy": "1. **Schema Verification**:\n   - Query information_schema to confirm table structure\n   - Verify all columns have correct data types and constraints\n   - Check that all indexes are created and active\n   - Confirm RLS is enabled on the table\n\n2. **CRUD Operations Testing**:\n   - Insert test collection with various calendar_sources configurations\n   - Query by GUID to verify unique index performance\n   - Update collection and verify updated_at trigger fires\n   - Delete collection and verify cascade behavior\n\n3. **RLS Policy Testing**:\n   - Test anonymous access to public collections\n   - Test authenticated user can only access their own collections\n   - Verify service role can bypass RLS for admin operations\n\n4. **Performance Testing**:\n   - Insert 1000+ test collections and measure query performance\n   - Test JSONB queries on calendar_sources field\n   - Verify index usage with EXPLAIN ANALYZE\n\n5. **Migration Rollback Plan**:\n   - Keep backup of any existing data\n   - Prepare rollback script to drop table and related objects\n   - Test rollback and re-application in development environment",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create database service layer for calendar collections with CRUD operations",
        "description": "Develop a service layer that interfaces with the Supabase database to perform CRUD operations on calendar collections, including proper error handling and validation.",
        "details": "Implement a comprehensive service layer that abstracts database interactions for calendar collections:\n\n1. **Service Structure**:\n   - Create a `CalendarCollectionService` class or module\n   - Implement singleton pattern or dependency injection for database client\n\n2. **CRUD Operations**:\n   - `getCollections()`: Retrieve all collections for the authenticated user\n   - `getCollectionById(id)`: Fetch a specific collection by ID\n   - `createCollection(data)`: Create a new collection with validation\n   - `updateCollection(id, data)`: Update an existing collection\n   - `deleteCollection(id)`: Remove a collection and handle cascading deletions\n\n3. **Error Handling**:\n   - Implement try/catch blocks for all database operations\n   - Create custom error classes (e.g., `CollectionNotFoundError`, `ValidationError`)\n   - Map database errors to appropriate application errors\n   - Provide meaningful error messages for client consumption\n\n4. **Validation**:\n   - Validate input data before database operations\n   - Ensure required fields are present\n   - Validate data types and formats (especially for calendar_sources JSON)\n   - Implement schema validation using a library like Zod or Joi\n\n5. **Transaction Support**:\n   - Implement transaction handling for operations that modify multiple records\n   - Ensure atomicity for complex operations\n\n6. **Performance Considerations**:\n   - Implement query optimization techniques\n   - Use appropriate indexes defined in the schema\n   - Consider pagination for large result sets\n\n7. **Security**:\n   - Respect RLS policies defined in the database\n   - Ensure proper user authentication context is passed to database queries\n   - Sanitize inputs to prevent SQL injection",
        "testStrategy": "1. **Unit Testing**:\n   - Create unit tests for each CRUD operation\n   - Mock the Supabase client to isolate service layer testing\n   - Test happy paths and error scenarios\n   - Verify validation logic works correctly\n   - Test custom error handling\n\n2. **Integration Testing**:\n   - Test service against a test database instance\n   - Verify data persistence and retrieval\n   - Test transactions roll back properly on errors\n   - Verify RLS policies are respected\n\n3. **Error Handling Tests**:\n   - Test with invalid inputs to verify validation\n   - Simulate database errors to test error handling\n   - Verify appropriate error messages are returned\n   - Test edge cases (null values, empty collections, etc.)\n\n4. **Performance Testing**:\n   - Measure response times for operations\n   - Test with large datasets to verify pagination\n   - Verify query performance using database execution plans\n\n5. **Security Testing**:\n   - Verify unauthorized access is prevented\n   - Test with different user contexts to ensure proper data isolation\n   - Attempt SQL injection to verify input sanitization\n\n6. **End-to-End Testing**:\n   - Create test scenarios that use the service layer from API endpoints\n   - Verify correct data flow from API to database and back",
        "status": "in-progress",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Test database integration for calendar collections",
        "description": "Create and execute integration tests to verify that all calendar collection CRUD operations work correctly with the Supabase database, ensuring data persistence and proper error handling.",
        "details": "Implement comprehensive integration tests for the calendar collection database functionality:\n\n1. **Test Environment Setup**:\n   - Create a test environment with a dedicated test database or isolated test data\n   - Implement test utilities for database cleanup before/after tests\n   - Set up authentication context for testing authenticated endpoints\n\n2. **Collection CRUD Test Cases**:\n   - **Create Collection Tests**:\n     - Test creating collections with valid data\n     - Verify validation prevents invalid data (missing required fields, invalid formats)\n     - Test error handling for duplicate GUIDs\n     - Verify created_at and updated_at timestamps are set correctly\n   \n   - **Read Collection Tests**:\n     - Test retrieving all collections for a user\n     - Test fetching a specific collection by ID\n     - Verify pagination and sorting functionality if implemented\n     - Test handling of non-existent collection IDs\n   \n   - **Update Collection Tests**:\n     - Test updating collection name, description, and calendar sources\n     - Verify partial updates work correctly\n     - Test concurrency handling (if implemented)\n     - Verify updated_at timestamp is updated\n   \n   - **Delete Collection Tests**:\n     - Test deletion of collections\n     - Verify cascade deletion of related data (if applicable)\n     - Test handling of non-existent collection IDs during deletion\n\n3. **Data Integrity Tests**:\n   - Verify data is persisted correctly after operations\n   - Test that RLS policies are enforced (users can only access their own collections)\n   - Verify JSON data types are handled correctly (calendar_sources)\n\n4. **Edge Cases**:\n   - Test behavior with large datasets\n   - Test handling of special characters in text fields\n   - Verify proper error responses for all failure scenarios",
        "testStrategy": "1. **Automated Test Suite**:\n   - Implement tests using a testing framework (Jest, Mocha, etc.)\n   - Create a CI pipeline job to run integration tests\n   - Generate test coverage reports\n\n2. **Test Execution Process**:\n   - Run tests against an isolated test database\n   - Execute the full test suite before merging code\n   - Verify all CRUD operations pass with expected results\n\n3. **Verification Steps**:\n   - Confirm all test cases pass consistently\n   - Verify database state after each test using direct database queries\n   - Check that error handling works as expected with appropriate status codes and messages\n   - Validate that RLS policies prevent unauthorized access\n\n4. **Performance Verification**:\n   - Measure and record response times for database operations\n   - Ensure operations complete within acceptable time limits\n   - Test with realistic data volumes\n\n5. **Manual Verification**:\n   - Perform manual testing through the API or UI to confirm integration test results\n   - Verify the application correctly reflects database changes\n   - Test real-world scenarios that might be difficult to automate",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-23T04:13:42.354Z",
      "updated": "2025-08-24T07:39:44.063Z",
      "description": "Implement persistent database storage using Supabase to replace in-memory collections system"
    }
  },
  "custom-ids-feature": {
    "tasks": [
      {
        "id": 1,
        "title": "Add Support for Optional customId Field in CreateCollectionRequest Interface",
        "description": "Extend the CreateCollectionRequest interface to include an optional customId field and implement validation logic to ensure custom IDs meet required format and uniqueness constraints.",
        "details": "1. Locate and modify the CreateCollectionRequest interface to add the optional customId field:\n```typescript\ninterface CreateCollectionRequest {\n  name: string;\n  description?: string;\n  customId?: string; // New optional field\n  // other existing fields...\n}\n```\n\n2. Implement validation logic for the customId field:\n   - Create a new validator function `validateCustomId(customId: string): boolean` that checks:\n     - Format constraints (alphanumeric characters, hyphens, underscores only)\n     - Length constraints (e.g., between 3-64 characters)\n     - Reserved word restrictions\n   - Add appropriate error messages for validation failures\n\n3. Modify the collection creation service to:\n   - Check if customId is provided\n   - If provided, validate using the new validation function\n   - If validation fails, return appropriate error response\n   - If validation passes, use the customId instead of generating a system ID\n\n4. Update any database schema or ORM models to accommodate the new field\n\n5. Update API documentation to reflect the new optional parameter\n\n6. Consider backward compatibility to ensure existing code using the interface continues to function correctly",
        "testStrategy": "1. Unit Tests:\n   - Create unit tests for the `validateCustomId` function with various inputs:\n     - Valid custom IDs (alphanumeric, with hyphens, with underscores)\n     - Invalid custom IDs (special characters, too short, too long, reserved words)\n   - Test the collection creation service with:\n     - No customId provided (should generate system ID)\n     - Valid customId provided (should use provided ID)\n     - Invalid customId provided (should return validation error)\n\n2. Integration Tests:\n   - Test the API endpoint for collection creation with and without customId\n   - Verify database entries correctly store the custom ID\n   - Test uniqueness constraints by attempting to create collections with duplicate customIds\n\n3. API Tests:\n   - Send requests to the collection creation endpoint with various customId scenarios\n   - Verify appropriate success and error responses\n   - Test that existing clients not using customId continue to work\n\n4. Documentation Verification:\n   - Ensure API documentation correctly describes the new optional parameter\n   - Verify that the documentation includes validation requirements",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Modify API Route POST Handler for Custom Collection IDs",
        "description": "Update the POST handler in /api/collections to accept the optional customId field, implement collision detection with 409 response, and fall back to UUID generation when customId is not provided.",
        "details": "1. Locate the POST handler in the /api/collections route file.\n\n2. Modify the handler to extract the optional customId from the request body:\n```typescript\nconst { name, description, customId, ...otherFields } = req.body;\n```\n\n3. Implement collision detection logic:\n```typescript\n// If customId is provided, check if it already exists\nif (customId) {\n  const existingCollection = await collectionRepository.findByCustomId(customId);\n  if (existingCollection) {\n    return res.status(409).json({\n      error: 'Conflict',\n      message: 'A collection with this customId already exists'\n    });\n  }\n}\n```\n\n4. Implement the fallback to UUID generation:\n```typescript\n// Generate a UUID if no customId is provided\nconst collectionId = customId || uuidv4();\n```\n\n5. Update the collection creation logic to use the determined ID:\n```typescript\nconst newCollection = await collectionRepository.create({\n  id: collectionId,\n  name,\n  description,\n  // other fields...\n});\n```\n\n6. Ensure the response includes the ID (whether custom or generated):\n```typescript\nreturn res.status(201).json({\n  id: newCollection.id,\n  name: newCollection.name,\n  // other fields...\n});\n```\n\n7. Update any relevant documentation or API specs to reflect the new behavior.\n\n8. Consider adding appropriate logging for both successful custom ID usage and collision detection events.",
        "testStrategy": "1. Unit Tests:\n   - Test the handler with a valid customId that doesn't exist yet (should return 201 with the collection using that ID)\n   - Test with a customId that already exists (should return 409 Conflict)\n   - Test without providing a customId (should return 201 with a UUID-generated ID)\n   - Test with an invalid customId format (should return 400 Bad Request, assuming validation from Task #1)\n\n2. Integration Tests:\n   - Create a collection with a custom ID via the API and verify it's stored correctly\n   - Attempt to create another collection with the same custom ID and verify the 409 response\n   - Create a collection without a custom ID and verify a UUID is generated\n   - Verify the generated or custom ID is correctly returned in the response\n\n3. API Tests:\n   - Use Postman or similar tool to manually test the API endpoint with various scenarios\n   - Verify the response format and status codes match the expected behavior\n\n4. Edge Cases:\n   - Test with empty string as customId\n   - Test with very long but valid customId\n   - Test concurrent requests with the same customId",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update Database Layer for Case-Insensitive Custom ID Uniqueness",
        "description": "Update the database layer in supabase.ts to implement case-insensitive uniqueness checks for custom IDs and handle duplicate key violations with appropriate error responses.",
        "details": "1. Locate the database access functions in the supabase.ts file that handle collection operations.\n\n2. Modify the `findByCustomId` function to perform case-insensitive searches:\n```typescript\nexport const findByCustomId = async (customId: string): Promise<Collection | null> => {\n  const { data, error } = await supabase\n    .from('collections')\n    .select('*')\n    .ilike('custom_id', customId) // Use ilike for case-insensitive matching\n    .maybeSingle();\n    \n  if (error) {\n    console.error('Error finding collection by custom ID:', error);\n    throw new DatabaseError('Failed to check for existing custom ID', error);\n  }\n  \n  return data;\n};\n```\n\n3. Create a new error class for duplicate key violations:\n```typescript\nexport class DuplicateKeyError extends Error {\n  constructor(message: string, public field: string) {\n    super(message);\n    this.name = 'DuplicateKeyError';\n  }\n}\n```\n\n4. Update the collection creation function to handle the case-insensitive uniqueness check:\n```typescript\nexport const createCollection = async (collection: CreateCollectionRequest): Promise<Collection> => {\n  // If customId is provided, check for case-insensitive duplicates first\n  if (collection.customId) {\n    const existing = await findByCustomId(collection.customId);\n    if (existing) {\n      throw new DuplicateKeyError(\n        `A collection with the custom ID '${collection.customId}' already exists`, \n        'customId'\n      );\n    }\n  }\n  \n  // Proceed with collection creation\n  const { data, error } = await supabase\n    .from('collections')\n    .insert({\n      name: collection.name,\n      description: collection.description,\n      custom_id: collection.customId,\n      // other fields...\n    })\n    .select()\n    .single();\n    \n  if (error) {\n    // Handle other potential database errors\n    console.error('Error creating collection:', error);\n    throw new DatabaseError('Failed to create collection', error);\n  }\n  \n  return data;\n};\n```\n\n5. Update any other relevant database functions that might need to handle custom IDs with case-insensitive checks.\n\n6. Ensure proper error propagation from the database layer to the API layer so that appropriate HTTP status codes can be returned.",
        "testStrategy": "1. Unit Tests:\n   - Test the `findByCustomId` function with:\n     - Exact case match (e.g., \"MyCollection\")\n     - Different case variations (e.g., \"mycollection\", \"MYCOLLECTION\")\n     - Non-existent IDs\n   - Test the `createCollection` function with:\n     - A new unique customId (should succeed)\n     - A customId that already exists with exact case (should throw DuplicateKeyError)\n     - A customId that already exists with different case (should throw DuplicateKeyError)\n     - No customId provided (should generate UUID)\n\n2. Integration Tests:\n   - Test the full flow from API to database and back:\n     - Create a collection with a custom ID\n     - Attempt to create another collection with the same ID but different case\n     - Verify the appropriate error response is returned\n\n3. Error Handling Tests:\n   - Verify that DuplicateKeyError is properly caught in the API layer\n   - Confirm that a 409 Conflict response is returned with an appropriate error message\n   - Test other database error scenarios to ensure they're handled correctly\n\n4. Performance Tests:\n   - Measure the performance impact of case-insensitive searches\n   - Ensure indexes are properly set up to support efficient case-insensitive lookups",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Comprehensive Test Suite for Custom ID Functionality",
        "description": "Create a comprehensive test suite that validates all aspects of the custom ID functionality including validation rules, collision detection, URL compatibility, and ensuring existing UUID functionality remains intact.",
        "details": "1. Create a test file `__tests__/customId.test.ts` to house all custom ID related tests.\n\n2. Implement validation rule tests:\n```typescript\ndescribe('Custom ID Validation', () => {\n  test('validates alphanumeric characters', () => {\n    expect(validateCustomId('abc123')).toBe(true);\n    expect(validateCustomId('abc!@#')).toBe(false);\n  });\n  \n  test('validates hyphens and underscores', () => {\n    expect(validateCustomId('my-custom_id')).toBe(true);\n  });\n  \n  test('validates length constraints', () => {\n    expect(validateCustomId('a'.repeat(3))).toBe(false); // too short\n    expect(validateCustomId('a'.repeat(64))).toBe(true);\n    expect(validateCustomId('a'.repeat(65))).toBe(false); // too long\n  });\n  \n  test('validates reserved words', () => {\n    expect(validateCustomId('api')).toBe(false);\n    expect(validateCustomId('admin')).toBe(false);\n  });\n});\n```\n\n3. Implement collision detection tests:\n```typescript\ndescribe('Custom ID Collision Detection', () => {\n  beforeEach(async () => {\n    // Set up test database with a collection that has customId \"existing-id\"\n    await setupTestCollection({ customId: 'existing-id' });\n  });\n  \n  test('detects collision with exact case match', async () => {\n    const response = await request(app)\n      .post('/api/collections')\n      .send({ name: 'Test Collection', customId: 'existing-id' });\n    \n    expect(response.status).toBe(409);\n    expect(response.body.error).toContain('already exists');\n  });\n  \n  test('detects collision with different case', async () => {\n    const response = await request(app)\n      .post('/api/collections')\n      .send({ name: 'Test Collection', customId: 'EXISTING-ID' });\n    \n    expect(response.status).toBe(409);\n  });\n});\n```\n\n4. Implement URL compatibility tests:\n```typescript\ndescribe('Custom ID URL Compatibility', () => {\n  test('custom IDs work in URL paths', async () => {\n    // First create a collection with a custom ID\n    const createResponse = await request(app)\n      .post('/api/collections')\n      .send({ name: 'URL Test', customId: 'url-friendly-id' });\n    \n    expect(createResponse.status).toBe(201);\n    \n    // Then try to fetch it using the custom ID\n    const getResponse = await request(app)\n      .get('/api/collections/url-friendly-id');\n    \n    expect(getResponse.status).toBe(200);\n    expect(getResponse.body.name).toBe('URL Test');\n  });\n  \n  test('custom IDs with special characters are properly encoded', async () => {\n    // Test with underscores and other allowed special chars\n    const createResponse = await request(app)\n      .post('/api/collections')\n      .send({ name: 'Special Chars', customId: 'test_id-123' });\n    \n    expect(createResponse.status).toBe(201);\n    \n    const getResponse = await request(app)\n      .get('/api/collections/test_id-123');\n    \n    expect(getResponse.status).toBe(200);\n  });\n});\n```\n\n5. Implement UUID fallback tests:\n```typescript\ndescribe('UUID Fallback Functionality', () => {\n  test('generates UUID when customId is not provided', async () => {\n    const response = await request(app)\n      .post('/api/collections')\n      .send({ name: 'UUID Fallback Test' });\n    \n    expect(response.status).toBe(201);\n    expect(response.body.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\n  });\n  \n  test('existing endpoints using UUID still work', async () => {\n    // Create a collection without custom ID (uses UUID)\n    const createResponse = await request(app)\n      .post('/api/collections')\n      .send({ name: 'UUID Test' });\n    \n    const uuid = createResponse.body.id;\n    \n    // Test that we can fetch it using the UUID\n    const getResponse = await request(app)\n      .get(`/api/collections/${uuid}`);\n    \n    expect(getResponse.status).toBe(200);\n    expect(getResponse.body.name).toBe('UUID Test');\n  });\n});\n```\n\n6. Implement integration tests that verify the entire flow:\n```typescript\ndescribe('Custom ID Integration Tests', () => {\n  test('full lifecycle with custom ID', async () => {\n    // Create\n    const createResponse = await request(app)\n      .post('/api/collections')\n      .send({ \n        name: 'Integration Test', \n        description: 'Testing the full lifecycle',\n        customId: 'integration-test-id'\n      });\n    \n    expect(createResponse.status).toBe(201);\n    expect(createResponse.body.customId).toBe('integration-test-id');\n    \n    // Read\n    const getResponse = await request(app)\n      .get('/api/collections/integration-test-id');\n    \n    expect(getResponse.status).toBe(200);\n    \n    // Update\n    const updateResponse = await request(app)\n      .put('/api/collections/integration-test-id')\n      .send({ name: 'Updated Integration Test' });\n    \n    expect(updateResponse.status).toBe(200);\n    \n    // Delete\n    const deleteResponse = await request(app)\n      .delete('/api/collections/integration-test-id');\n    \n    expect(deleteResponse.status).toBe(204);\n    \n    // Verify deletion\n    const getAfterDeleteResponse = await request(app)\n      .get('/api/collections/integration-test-id');\n    \n    expect(getAfterDeleteResponse.status).toBe(404);\n  });\n});\n```",
        "testStrategy": "1. Run unit tests for the validation function:\n   - Execute `npm test -- customId.test.ts` to run all custom ID tests\n   - Verify all validation rules pass with valid inputs and fail with invalid inputs\n   - Check edge cases like minimum/maximum length, special characters\n\n2. Run integration tests for collision detection:\n   - Set up test database with predefined collections having known custom IDs\n   - Verify that attempts to create collections with duplicate IDs (case-insensitive) return 409 status\n   - Confirm error messages clearly indicate the collision issue\n\n3. Test URL compatibility:\n   - Create collections with various custom IDs including hyphens and underscores\n   - Verify that these collections can be retrieved via their custom IDs in URL paths\n   - Test URL encoding/decoding works correctly with all allowed special characters\n\n4. Verify UUID fallback functionality:\n   - Create collections without specifying custom IDs\n   - Confirm they receive valid UUIDs\n   - Verify these collections can be accessed via their UUID\n\n5. Perform end-to-end testing:\n   - Test the complete CRUD lifecycle using custom IDs\n   - Verify all operations (create, read, update, delete) work correctly with custom IDs\n   - Confirm that existing code paths using UUIDs continue to function properly\n\n6. Run regression tests:\n   - Ensure all existing functionality that previously used UUIDs still works\n   - Verify that no regressions have been introduced in the collection management system\n\n7. Document test results:\n   - Create a test report documenting coverage and results\n   - Note any edge cases or potential improvements for future iterations",
        "status": "done",
        "dependencies": [
          1,
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-24T08:18:43.726Z",
      "updated": "2025-08-24T08:31:53.176Z",
      "description": "Implementation of user-provided custom IDs for calendar collections as an alternative to auto-generated UUIDs"
    }
  }
}