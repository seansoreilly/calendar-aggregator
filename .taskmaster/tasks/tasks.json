{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Supabase Database Schema",
        "description": "Design and implement the database schema in Supabase to store calendar collections persistently",
        "details": "1. Create a new table called 'calendar_collections' in Supabase with the following columns:\n   - guid: UUID (primary key)\n   - name: TEXT (not null)\n   - description: TEXT\n   - sources: JSONB (not null)\n   - created_at: TIMESTAMP WITH TIME ZONE (default: now())\n   - updated_at: TIMESTAMP WITH TIME ZONE (default: now())\n\n2. Set up appropriate indexes:\n   - Primary key on guid\n   - Index on created_at for potential sorting/filtering\n\n3. Configure Row Level Security (RLS) policies if needed for future user authentication\n\n4. Create a TypeScript interface that matches the CalendarCollection type but includes the additional database fields:\n\n```typescript\ninterface StoredCalendarCollection extends CalendarCollection {\n  created_at: string;\n  updated_at: string;\n}\n```",
        "testStrategy": "1. Verify table creation in Supabase dashboard\n2. Test inserting a sample record manually through the Supabase interface\n3. Confirm data types are correctly defined, especially the JSONB for sources\n4. Validate that created_at and updated_at fields are automatically populated\n5. Ensure the schema matches the existing CalendarCollection TypeScript type",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Supabase Client Configuration",
        "description": "Set up Supabase client integration with environment variables for the application",
        "details": "1. Install required dependencies:\n```bash\nnpm install @supabase/supabase-js\n```\n\n2. Create a utility file for Supabase client initialization (e.g., `lib/supabase.ts`):\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n\n3. Update environment configuration:\n   - Add the following to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n   - Update `.env.example` to include these variables\n   - Update deployment documentation to include Supabase environment variables\n\n4. Create a simple test function to verify connection:\n```typescript\nexport async function testSupabaseConnection() {\n  try {\n    const { data, error } = await supabase.from('calendar_collections').select('count');\n    if (error) throw error;\n    return { success: true };\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return { success: false, error };\n  }\n}\n```",
        "testStrategy": "1. Create a simple test endpoint that calls testSupabaseConnection()\n2. Verify connection succeeds with valid environment variables\n3. Verify appropriate error handling when environment variables are missing\n4. Test connection in both development and production environments\n5. Ensure environment variables are properly loaded in all environments",
        "priority": "high",
        "dependencies": [1],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update API Routes for Supabase Integration",
        "description": "Refactor existing API routes to use Supabase for persistent storage instead of in-memory storage",
        "details": "1. Create a service layer for calendar collections (e.g., `services/calendarCollections.ts`):\n```typescript\nimport { supabase } from '../lib/supabase';\nimport { v4 as uuidv4 } from 'uuid';\nimport { CalendarCollection } from '../types';\n\nexport async function getAllCollections() {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .order('created_at', { ascending: false });\n  \n  if (error) throw error;\n  return data as CalendarCollection[];\n}\n\nexport async function getCollectionByGuid(guid: string) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .eq('guid', guid)\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function createCollection(collection: Omit<CalendarCollection, 'guid'>) {\n  const guid = uuidv4();\n  const newCollection = { ...collection, guid };\n  \n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .insert([newCollection])\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function updateCollection(guid: string, updates: Partial<CalendarCollection>) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .update({ ...updates, updated_at: new Date() })\n    .eq('guid', guid)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function deleteCollection(guid: string) {\n  const { error } = await supabase\n    .from('calendar_collections')\n    .delete()\n    .eq('guid', guid);\n  \n  if (error) throw error;\n  return { success: true };\n}\n```\n\n2. Update API routes to use the service layer:\n\n- `/api/collections.ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getAllCollections, createCollection } from '../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    if (req.method === 'GET') {\n      const collections = await getAllCollections();\n      return res.status(200).json(collections);\n    } else if (req.method === 'POST') {\n      const collection = await createCollection(req.body);\n      return res.status(201).json(collection);\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n- `/api/collections/[guid].ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getCollectionByGuid, updateCollection, deleteCollection } from '../../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { guid } = req.query;\n  \n  if (!guid || Array.isArray(guid)) {\n    return res.status(400).json({ message: 'Invalid guid parameter' });\n  }\n  \n  try {\n    if (req.method === 'GET') {\n      const collection = await getCollectionByGuid(guid);\n      return res.status(200).json(collection);\n    } else if (req.method === 'PUT') {\n      const collection = await updateCollection(guid, req.body);\n      return res.status(200).json(collection);\n    } else if (req.method === 'DELETE') {\n      await deleteCollection(guid);\n      return res.status(204).end();\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n3. Add backward compatibility with existing in-memory storage during transition:\n```typescript\n// In the service layer, add fallback to in-memory storage\nexport async function getAllCollections() {\n  try {\n    const { data, error } = await supabase\n      .from('calendar_collections')\n      .select('*')\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data as CalendarCollection[];\n  } catch (error) {\n    console.warn('Falling back to in-memory storage', error);\n    return globalThis.calendarCollections || [];\n  }\n}\n```",
        "testStrategy": "1. Create unit tests for each service function\n2. Test each API endpoint with valid and invalid requests\n3. Verify error handling for database connection issues\n4. Test backward compatibility with existing API response format\n5. Verify CRUD operations work correctly with Supabase\n6. Test performance and response times compared to in-memory storage\n7. Ensure proper error responses for invalid requests",
        "priority": "medium",
        "dependencies": [1, 2],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Deployment and Documentation Updates",
        "description": "Update deployment process and documentation to include Supabase integration requirements",
        "details": "1. Update README.md with Supabase setup instructions:\n```markdown\n## Supabase Setup\n\n1. Create a Supabase project at https://supabase.com\n2. Create the `calendar_collections` table using the SQL in `schema.sql`\n3. Get your Supabase URL and anon key from the project settings\n4. Add these to your environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n```\n\n2. Create a `schema.sql` file with the table creation SQL:\n```sql\nCREATE TABLE calendar_collections (\n  guid UUID PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  sources JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE INDEX idx_calendar_collections_created_at ON calendar_collections(created_at);\n```\n\n3. Update deployment scripts or configuration:\n   - Add Supabase environment variables to deployment platform (Vercel, Netlify, etc.)\n   - Create a deployment checklist that includes Supabase setup\n\n4. Create a simple health check endpoint to verify Supabase connection:\n```typescript\n// pages/api/health.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { testSupabaseConnection } from '../../lib/supabase';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ message: 'Method not allowed' });\n  }\n\n  try {\n    const connectionStatus = await testSupabaseConnection();\n    return res.status(200).json({\n      status: 'ok',\n      supabase: connectionStatus.success ? 'connected' : 'error',\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error('Health check error:', error);\n    return res.status(500).json({ status: 'error', message: 'Internal server error' });\n  }\n}\n```\n\n5. Add logging for monitoring database operations in production",
        "testStrategy": "1. Verify README.md instructions are clear and complete\n2. Test schema.sql script in a fresh Supabase project\n3. Verify health check endpoint correctly reports connection status\n4. Test deployment process on staging environment\n5. Verify environment variables are correctly set in production\n6. Create a deployment checklist and verify all steps\n7. Test the application after deployment to ensure collections persist",
        "priority": "low",
        "dependencies": [1, 2, 3],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-20T06:49:44.250Z",
      "updated": "2025-08-20T06:49:58.088Z",
      "description": "Tasks for master context"
    }
  },
  "supabase-backend": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Supabase Database Schema",
        "description": "Design and implement the database schema in Supabase to store calendar collections persistently",
        "details": "1. Create a new table called 'calendar_collections' in Supabase with the following columns:\n   - guid: UUID (primary key)\n   - name: TEXT (not null)\n   - description: TEXT\n   - sources: JSONB (not null)\n   - created_at: TIMESTAMP WITH TIME ZONE (default: now())\n   - updated_at: TIMESTAMP WITH TIME ZONE (default: now())\n\n2. Set up appropriate indexes:\n   - Primary key on guid\n   - Index on created_at for potential sorting/filtering\n\n3. Configure Row Level Security (RLS) policies if needed for future user authentication\n\n4. Create a TypeScript interface that matches the CalendarCollection type but includes the additional database fields:\n\n```typescript\ninterface StoredCalendarCollection extends CalendarCollection {\n  created_at: string;\n  updated_at: string;\n}\n```",
        "testStrategy": "1. Verify table creation in Supabase dashboard\n2. Test inserting a sample record manually through the Supabase interface\n3. Confirm data types are correctly defined, especially the JSONB for sources\n4. Validate that created_at and updated_at fields are automatically populated\n5. Ensure the schema matches the existing CalendarCollection TypeScript type",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Supabase Client Configuration",
        "description": "Set up Supabase client integration with environment variables for the application",
        "details": "1. Install required dependencies:\n```bash\nnpm install @supabase/supabase-js\n```\n\n2. Create a utility file for Supabase client initialization (e.g., `lib/supabase.ts`):\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n\n3. Update environment configuration:\n   - Add the following to `.env.local`:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n   - Update `.env.example` to include these variables\n   - Update deployment documentation to include Supabase environment variables\n\n4. Create a simple test function to verify connection:\n```typescript\nexport async function testSupabaseConnection() {\n  try {\n    const { data, error } = await supabase.from('calendar_collections').select('count');\n    if (error) throw error;\n    return { success: true };\n  } catch (error) {\n    console.error('Supabase connection error:', error);\n    return { success: false, error };\n  }\n}\n```",
        "testStrategy": "1. Create a simple test endpoint that calls testSupabaseConnection()\n2. Verify connection succeeds with valid environment variables\n3. Verify appropriate error handling when environment variables are missing\n4. Test connection in both development and production environments\n5. Ensure environment variables are properly loaded in all environments",
        "priority": "high",
        "dependencies": [1],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update API Routes for Supabase Integration",
        "description": "Refactor existing API routes to use Supabase for persistent storage instead of in-memory storage",
        "details": "1. Create a service layer for calendar collections (e.g., `services/calendarCollections.ts`):\n```typescript\nimport { supabase } from '../lib/supabase';\nimport { v4 as uuidv4 } from 'uuid';\nimport { CalendarCollection } from '../types';\n\nexport async function getAllCollections() {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .order('created_at', { ascending: false });\n  \n  if (error) throw error;\n  return data as CalendarCollection[];\n}\n\nexport async function getCollectionByGuid(guid: string) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .select('*')\n    .eq('guid', guid)\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function createCollection(collection: Omit<CalendarCollection, 'guid'>) {\n  const guid = uuidv4();\n  const newCollection = { ...collection, guid };\n  \n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .insert([newCollection])\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function updateCollection(guid: string, updates: Partial<CalendarCollection>) {\n  const { data, error } = await supabase\n    .from('calendar_collections')\n    .update({ ...updates, updated_at: new Date() })\n    .eq('guid', guid)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as CalendarCollection;\n}\n\nexport async function deleteCollection(guid: string) {\n  const { error } = await supabase\n    .from('calendar_collections')\n    .delete()\n    .eq('guid', guid);\n  \n  if (error) throw error;\n  return { success: true };\n}\n```\n\n2. Update API routes to use the service layer:\n\n- `/api/collections.ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getAllCollections, createCollection } from '../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    if (req.method === 'GET') {\n      const collections = await getAllCollections();\n      return res.status(200).json(collections);\n    } else if (req.method === 'POST') {\n      const collection = await createCollection(req.body);\n      return res.status(201).json(collection);\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n- `/api/collections/[guid].ts`:\n```typescript\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getCollectionByGuid, updateCollection, deleteCollection } from '../../../services/calendarCollections';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { guid } = req.query;\n  \n  if (!guid || Array.isArray(guid)) {\n    return res.status(400).json({ message: 'Invalid guid parameter' });\n  }\n  \n  try {\n    if (req.method === 'GET') {\n      const collection = await getCollectionByGuid(guid);\n      return res.status(200).json(collection);\n    } else if (req.method === 'PUT') {\n      const collection = await updateCollection(guid, req.body);\n      return res.status(200).json(collection);\n    } else if (req.method === 'DELETE') {\n      await deleteCollection(guid);\n      return res.status(204).end();\n    }\n    return res.status(405).json({ message: 'Method not allowed' });\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n3. Add backward compatibility with existing in-memory storage during transition:\n```typescript\n// In the service layer, add fallback to in-memory storage\nexport async function getAllCollections() {\n  try {\n    const { data, error } = await supabase\n      .from('calendar_collections')\n      .select('*')\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return data as CalendarCollection[];\n  } catch (error) {\n    console.warn('Falling back to in-memory storage', error);\n    return globalThis.calendarCollections || [];\n  }\n}\n```",
        "testStrategy": "1. Create unit tests for each service function\n2. Test each API endpoint with valid and invalid requests\n3. Verify error handling for database connection issues\n4. Test backward compatibility with existing API response format\n5. Verify CRUD operations work correctly with Supabase\n6. Test performance and response times compared to in-memory storage\n7. Ensure proper error responses for invalid requests",
        "priority": "medium",
        "dependencies": [1, 2],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Deployment and Documentation Updates",
        "description": "Update deployment process and documentation to include Supabase integration requirements",
        "details": "1. Update README.md with Supabase setup instructions:\n```markdown\n## Supabase Setup\n\n1. Create a Supabase project at https://supabase.com\n2. Create the `calendar_collections` table using the SQL in `schema.sql`\n3. Get your Supabase URL and anon key from the project settings\n4. Add these to your environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   ```\n```\n\n2. Create a `schema.sql` file with the table creation SQL:\n```sql\nCREATE TABLE calendar_collections (\n  guid UUID PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  sources JSONB NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE INDEX idx_calendar_collections_created_at ON calendar_collections(created_at);\n```\n\n3. Update deployment scripts or configuration:\n   - Add Supabase environment variables to deployment platform (Vercel, Netlify, etc.)\n   - Create a deployment checklist that includes Supabase setup\n\n4. Create a simple health check endpoint to verify Supabase connection:\n```typescript\n// pages/api/health.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { testSupabaseConnection } from '../../lib/supabase';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ message: 'Method not allowed' });\n  }\n\n  try {\n    const connectionStatus = await testSupabaseConnection();\n    return res.status(200).json({\n      status: 'ok',\n      supabase: connectionStatus.success ? 'connected' : 'error',\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error('Health check error:', error);\n    return res.status(500).json({ status: 'error', message: 'Internal server error' });\n  }\n}\n```\n\n5. Add logging for monitoring database operations in production",
        "testStrategy": "1. Verify README.md instructions are clear and complete\n2. Test schema.sql script in a fresh Supabase project\n3. Verify health check endpoint correctly reports connection status\n4. Test deployment process on staging environment\n5. Verify environment variables are correctly set in production\n6. Create a deployment checklist and verify all steps\n7. Test the application after deployment to ensure collections persist",
        "priority": "low",
        "dependencies": [1, 2, 3],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-20T06:50:18.280Z",
      "updated": "2025-08-20T07:10:03.790Z",
      "description": "Implement Supabase backend for persistent calendar GUID storage"
    }
  },
  "dependency-cleanup": {
    "tasks": [
      {
        "id": 1,
        "title": "Remove Unused Radix UI Dependencies",
        "description": "Remove unused Radix UI dependencies and class-variance-authority from package.json to reduce bundle size by approximately 200-400KB.",
        "details": "This task involves removing the following unused dependencies from the project's package.json file:\n\n1. @radix-ui/react-dialog\n2. @radix-ui/react-select\n3. @radix-ui/react-toast\n4. class-variance-authority\n\nSteps to complete this task:\n1. Open the project's package.json file.\n2. Locate the dependencies section.\n3. Remove the entries for the four packages listed above.\n4. Run `npm install` or `yarn` (depending on the package manager used in the project) to update the lock file.\n5. Verify that the packages are no longer listed in the dependencies section of package.json.\n6. Verify that the node_modules folder no longer contains these packages after reinstallation.\n\nNote: Before removing these dependencies, perform a final verification by searching the entire codebase for any imports of these packages to ensure they are truly unused. This can be done using grep or a similar search tool:\n\n```bash\ngrep -r \"@radix-ui/react-dialog\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\ngrep -r \"@radix-ui/react-select\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\ngrep -r \"@radix-ui/react-toast\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\ngrep -r \"class-variance-authority\" --include=\"*.js\" --include=\"*.jsx\" --include=\"*.ts\" --include=\"*.tsx\" ./src\n```\n\nThe expected outcome is a reduction in bundle size by approximately 200-400KB, which should improve application load times and performance.",
        "testStrategy": "To verify that this task has been completed successfully:\n\n1. Check that package.json no longer contains the following dependencies:\n   - @radix-ui/react-dialog\n   - @radix-ui/react-select\n   - @radix-ui/react-toast\n   - class-variance-authority\n\n2. Verify that the package-lock.json or yarn.lock file has been updated accordingly.\n\n3. Run a build of the application and ensure it compiles without errors:\n   ```bash\n   npm run build\n   # or\n   yarn build\n   ```\n\n4. Compare the bundle size before and after the changes to confirm the expected reduction:\n   - Use a tool like `source-map-explorer` or the built-in bundle analyzer if available\n   - Verify that the bundle size has decreased by approximately 200-400KB\n\n5. Run the application and perform basic smoke tests to ensure no functionality has been broken:\n   - Navigate through main application flows\n   - Test any UI components that might have been using these dependencies indirectly\n   - Check the browser console for any unexpected errors\n\n6. Run the existing test suite to ensure all tests still pass:\n   ```bash\n   npm test\n   # or\n   yarn test\n   ```",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Remove Unused Tailwind Plugins",
        "description": "Remove unused Tailwind plugins (@tailwindcss/forms and @tailwindcss/typography) from devDependencies and tailwind.config.ts to reduce bundle size and simplify the configuration.",
        "details": "This task involves removing unused Tailwind CSS plugins that are currently configured but not being utilized in the codebase.\n\nSteps to complete this task:\n1. Open the project's package.json file.\n2. Locate the devDependencies section.\n3. Remove the entries for the following packages:\n   - @tailwindcss/forms\n   - @tailwindcss/typography\n4. Open the tailwind.config.ts file.\n5. Find the plugins array in the configuration.\n6. Remove the references to these plugins. They might look like:\n   ```typescript\n   plugins: [\n     require('@tailwindcss/forms'),\n     require('@tailwindcss/typography'),\n     // other plugins...\n   ],\n   ```\n7. Run `npm install` or `yarn` (depending on the package manager used in the project) to update the lock file.\n8. Rebuild the project to ensure that the Tailwind CSS configuration still works correctly without these plugins.\n9. Verify that no styling issues appear in the UI after removing these plugins, confirming they were indeed unused.\n\nNote: This task is similar to Task #1 in that it involves removing unused dependencies, but focuses specifically on Tailwind CSS plugins rather than Radix UI components.",
        "testStrategy": "To verify that this task has been completed successfully:\n\n1. Check that package.json no longer contains the following devDependencies:\n   - @tailwindcss/forms\n   - @tailwindcss/typography\n\n2. Verify that tailwind.config.ts no longer includes these plugins in its plugins array.\n\n3. Run the following commands to ensure the project builds correctly:\n   ```bash\n   npm install  # or yarn\n   npm run build  # or the appropriate build command for the project\n   ```\n\n4. Inspect the application UI in various states and pages to confirm that:\n   - No console errors related to missing Tailwind plugins appear\n   - All UI elements maintain their expected styling\n   - No form elements or typography elements have lost their styling\n\n5. Verify that the package-lock.json or yarn.lock file has been updated to remove these dependencies.\n\n6. Run Lighthouse or a similar performance tool to confirm that the bundle size has been reduced.",
        "status": "done",
        "dependencies": [1],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Update Dependencies: Remove Unused Testing Library and Audit Axios",
        "description": "Remove @testing-library/user-event from devDependencies since it's not being used in any test files, and audit axios to update it to the latest version for security patches.",
        "details": "This task involves cleaning up unused dependencies and ensuring security by updating a critical package.\n\nSteps to complete this task:\n1. Open the project's package.json file.\n2. Locate the devDependencies section.\n3. Remove the entry for @testing-library/user-event.\n4. Run `npm audit` or `yarn audit` (depending on the package manager used in the project) to check for vulnerabilities in the axios package.\n5. If vulnerabilities are found, update axios to the latest version:\n   - For npm: `npm update axios` or `npm install axios@latest`\n   - For yarn: `yarn upgrade axios` or `yarn add axios@latest`\n6. Run the application and tests to ensure the update doesn't break existing functionality.\n7. Update the package-lock.json or yarn.lock file by running `npm install` or `yarn`.\n8. Document any significant changes in the axios API that might affect the codebase.\n\nConsiderations:\n- Before removing @testing-library/user-event, verify it's truly not used by searching through all test files.\n- Check for any imports like `import userEvent from '@testing-library/user-event'` or similar.\n- When updating axios, review the changelog between the current version and the latest to understand potential breaking changes.\n- If the axios update introduces breaking changes, document them and make necessary adjustments to the codebase.",
        "testStrategy": "To verify that this task has been completed successfully:\n\n1. Check that package.json no longer contains @testing-library/user-event in the devDependencies section:\n   ```\n   grep -r \"@testing-library/user-event\" package.json\n   ```\n   This should return no results.\n\n2. Verify that no test files are importing @testing-library/user-event:\n   ```\n   grep -r \"from '@testing-library/user-event'\" --include=\"*.test.*\" .\n   grep -r \"from \\\"@testing-library/user-event\\\"\" --include=\"*.test.*\" .\n   ```\n   Both commands should return no results.\n\n3. Confirm axios has been updated to the latest version:\n   ```\n   npm list axios\n   ```\n   or\n   ```\n   yarn why axios\n   ```\n   The output should show the latest version available.\n\n4. Run the application's test suite to ensure all tests pass:\n   ```\n   npm test\n   ```\n   or\n   ```\n   yarn test\n   ```\n\n5. Run a security audit to verify no vulnerabilities remain:\n   ```\n   npm audit\n   ```\n   or\n   ```\n   yarn audit\n   ```\n   There should be no high or critical vulnerabilities related to axios.\n\n6. Manually test any features that rely on axios to ensure they still function correctly after the update.",
        "status": "done",
        "dependencies": [1, 2],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:37.719Z",
      "updated": "2025-08-22T09:38:44.798Z",
      "description": "Remove unused dependencies and optimize package.json"
    }
  },
  "code-deduplication": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Shared HTTP Client Utility for Calendar Operations",
        "description": "Develop a centralized HTTP client utility that consolidates duplicate axios configurations currently spread across calendar-utils.ts and calendar-fetcher.ts, including common timeout settings, User-Agent headers, and error handling patterns.",
        "details": "1. Create a new file named `http-client.ts` in an appropriate utilities or shared directory.\n\n2. Implement a configurable axios instance with the following features:\n   - Default timeout configuration (likely matching the current timeout in both files)\n   - Standard User-Agent headers\n   - Consistent error handling middleware\n   - Optional request/response interceptors\n   - Typed response handling\n\n3. Example implementation:\n```typescript\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';\n\n// Default configuration\nconst DEFAULT_TIMEOUT = 30000; // or whatever the current timeout is\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'YourAppName/1.0', // match existing User-Agent\n  'Content-Type': 'application/json'\n};\n\n// Error handling types\nexport interface ErrorResponse {\n  message: string;\n  code?: string;\n  details?: any;\n}\n\n// Create the HTTP client factory\nexport function createHttpClient(config: AxiosRequestConfig = {}): AxiosInstance {\n  const instance = axios.create({\n    timeout: DEFAULT_TIMEOUT,\n    headers: DEFAULT_HEADERS,\n    ...config\n  });\n\n  // Add request interceptor\n  instance.interceptors.request.use(\n    (config) => {\n      // Any request preprocessing\n      return config;\n    },\n    (error) => Promise.reject(error)\n  );\n\n  // Add response interceptor with standardized error handling\n  instance.interceptors.response.use(\n    (response) => response,\n    (error: AxiosError) => {\n      const errorResponse: ErrorResponse = {\n        message: 'An error occurred during the request',\n        details: error.response?.data\n      };\n      \n      if (error.response) {\n        errorResponse.code = `HTTP_${error.response.status}`;\n      } else if (error.request) {\n        errorResponse.code = 'NETWORK_ERROR';\n      } else {\n        errorResponse.code = 'REQUEST_SETUP_ERROR';\n      }\n      \n      return Promise.reject(errorResponse);\n    }\n  );\n\n  return instance;\n}\n\n// Export a default instance for common use\nexport const httpClient = createHttpClient();\n\n// Calendar-specific client with any special configurations\nexport const calendarHttpClient = createHttpClient({\n  // Any calendar-specific defaults\n});\n```\n\n4. Refactor calendar-utils.ts and calendar-fetcher.ts to use the new shared HTTP client:\n   - Import the appropriate client (default or calendar-specific)\n   - Replace direct axios calls with the new client\n   - Remove duplicate configuration code\n   - Ensure error handling is consistent with the new pattern\n\n5. Consider adding additional utility methods specific to calendar operations if needed.",
        "testStrategy": "1. Unit Tests:\n   - Create unit tests for the HTTP client utility using Jest or your project's testing framework\n   - Test the default configuration is applied correctly\n   - Mock axios responses to verify error handling works as expected\n   - Test that custom configurations properly override defaults\n   - Verify interceptors are properly applied\n\n2. Integration Tests:\n   - Create tests that verify calendar-utils.ts and calendar-fetcher.ts work correctly with the new client\n   - Test actual API calls to ensure timeout, headers, and error handling work in real scenarios\n   - Compare responses between old implementation and new implementation to ensure they match\n\n3. Error Handling Tests:\n   - Simulate network errors, timeout errors, and server errors to verify proper error handling\n   - Verify error objects contain the expected properties and formats\n   - Test error logging functionality if applicable\n\n4. Code Review Verification:\n   - Verify that all instances of axios in the calendar files have been replaced with the new client\n   - Confirm that no duplicate configuration exists across the files\n   - Check that the error handling is consistent\n\n5. Performance Testing:\n   - Verify that the refactored code doesn't introduce any performance regressions\n   - Test response times for typical calendar operations",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Extract Global Storage Management into Shared Module",
        "description": "Create a centralized utility module that consolidates duplicate storage initialization functions and global variable declarations currently spread across multiple API route files.",
        "details": "1. Create a new file named `storage-manager.ts` in the utilities or shared directory.\n\n2. Identify and extract the common storage initialization patterns from the 4+ API route files:\n   - Global variable declarations\n   - The `initializeStorage()` function\n   - Any related helper functions or type definitions\n\n3. Implement a clean API for the storage module:\n```typescript\n// storage-manager.ts\nimport { Storage } from '@google-cloud/storage'; // or whatever storage library is being used\n\n// Singleton instance\nlet storageInstance: Storage | null = null;\n\n// Configuration interface\nexport interface StorageConfig {\n  projectId?: string;\n  keyFilename?: string;\n  // Add other relevant configuration options\n}\n\n/**\n * Initialize and return a storage instance\n * @param config Optional configuration to override defaults\n * @returns Configured Storage instance\n */\nexport function getStorageInstance(config: StorageConfig = {}): Storage {\n  if (!storageInstance) {\n    storageInstance = new Storage({\n      // Default configuration\n      ...config\n    });\n  }\n  return storageInstance;\n}\n\n/**\n * Reset the storage instance (primarily for testing)\n */\nexport function resetStorageInstance(): void {\n  storageInstance = null;\n}\n\n// Export any other utility functions related to storage management\n```\n\n4. Update all API route files to import and use the new shared module:\n   - Replace local storage initialization with imports from the new module\n   - Remove duplicate code\n   - Ensure consistent configuration across all routes\n\n5. Consider adding additional utility functions that might be useful across routes:\n   - File upload helpers\n   - Common bucket operations\n   - Error handling specific to storage operations",
        "testStrategy": "1. Unit Tests:\n   - Create unit tests for the storage manager module using Jest or your project's testing framework\n   - Test the singleton pattern works correctly (multiple calls return the same instance)\n   - Test that configuration options properly override defaults\n   - Test the reset functionality works as expected\n   - Mock the storage library to verify interactions\n\n2. Integration Tests:\n   - Verify that all API routes that previously used local storage initialization now correctly use the shared module\n   - Test with a test bucket to ensure actual storage operations still work correctly\n   - Verify error handling works consistently across all routes\n\n3. Manual Testing:\n   - Execute each API endpoint that uses storage functionality to verify it still works correctly\n   - Check logs to ensure no duplicate initialization is occurring\n   - Verify performance is maintained or improved\n\n4. Code Review:\n   - Ensure all duplicate code has been removed from API route files\n   - Verify consistent usage patterns across the codebase",
        "status": "pending",
        "dependencies": [1],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create API Response Utilities for Standardized Error and Success Handling",
        "description": "Develop a centralized utility module that standardizes API response formats for both success and error cases, eliminating duplicate error handling patterns across API routes.",
        "details": "1. Create a new file named `api-response.ts` in the utilities or shared directory.\n\n2. Define standardized response interfaces:\n```typescript\nexport interface ApiSuccessResponse<T> {\n  success: true;\n  data: T;\n  message?: string;\n}\n\nexport interface ApiErrorResponse {\n  success: false;\n  error: {\n    code: string;\n    message: string;\n    details?: any;\n  };\n  statusCode: number;\n}\n\nexport type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;\n```\n\n3. Implement utility functions for creating consistent responses:\n```typescript\nexport const createSuccessResponse = <T>(data: T, message?: string): ApiSuccessResponse<T> => ({\n  success: true,\n  data,\n  message\n});\n\nexport const createErrorResponse = (\n  message: string,\n  statusCode: number = 500,\n  code: string = 'INTERNAL_ERROR',\n  details?: any\n): ApiErrorResponse => ({\n  success: false,\n  error: {\n    code,\n    message,\n    details\n  },\n  statusCode\n});\n\n// Common error factory functions\nexport const notFoundError = (resource: string) => \n  createErrorResponse(`${resource} not found`, 404, 'NOT_FOUND');\n\nexport const fetchFailedError = (resource: string, details?: any) => \n  createErrorResponse(`Failed to fetch ${resource}`, 500, 'FETCH_FAILED', details);\n\n// Additional common error patterns as needed\n```\n\n4. Create Express middleware for consistent error handling:\n```typescript\nimport { Request, Response, NextFunction } from 'express';\n\nexport const errorHandler = (\n  err: any,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  console.error('API Error:', err);\n  \n  // Handle known error types\n  if (err.name === 'NotFoundError') {\n    return res.status(404).json(notFoundError(err.resource || 'Resource'));\n  }\n  \n  // Default error response\n  const statusCode = err.statusCode || 500;\n  const errorResponse = createErrorResponse(\n    err.message || 'An unexpected error occurred',\n    statusCode,\n    err.code || 'INTERNAL_ERROR',\n    process.env.NODE_ENV === 'development' ? err.stack : undefined\n  );\n  \n  res.status(statusCode).json(errorResponse);\n};\n```\n\n5. Update existing API routes to use the new utility:\n   - Identify all routes with duplicate error handling patterns\n   - Replace custom error responses with the standardized utility functions\n   - Ensure consistent status codes are used across the application\n\n6. Document the new response format for API consumers, including:\n   - Expected response structure for success and error cases\n   - Common error codes and their meanings\n   - HTTP status code usage",
        "testStrategy": "1. Unit Tests:\n   - Create comprehensive unit tests for the API response utility functions\n   - Test all success response scenarios with various data types\n   - Test all error response scenarios with different status codes and messages\n   - Verify that error factory functions generate the correct format\n   - Test the error middleware with various error types\n\n2. Integration Tests:\n   - Create tests that verify API endpoints return the standardized response format\n   - Test both success and error scenarios for each endpoint\n   - Verify that error responses maintain consistency across different error conditions\n   - Test that status codes are appropriate for the error types\n\n3. Documentation Testing:\n   - Verify that the API documentation accurately reflects the new response format\n   - Create examples of success and error responses for documentation\n   - Ensure error codes are well-documented with clear explanations\n\n4. Manual Testing:\n   - Use API testing tools like Postman to verify response formats\n   - Test edge cases such as empty responses, large payloads, and unusual error conditions\n   - Verify that client applications can properly parse and handle the standardized responses\n\n5. Regression Testing:\n   - Ensure that existing functionality continues to work after implementing the standardized responses\n   - Verify that client applications expecting the old format are not broken (if backward compatibility is required)",
        "status": "pending",
        "dependencies": [1],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Consolidate Supabase Operations with Shared Database Utilities",
        "description": "Create a centralized database utility module that consolidates duplicate Supabase operations, fallback logic, and data transformation patterns currently spread across multiple collection endpoints.",
        "details": "1. Create a new file named `supabase-utils.ts` in the utilities or shared directory.\n\n2. Identify and extract common Supabase operation patterns from collection endpoints:\n   - Connection initialization and configuration\n   - Error handling and fallback logic\n   - Data transformation between DB format and app format\n   - Query building patterns\n   - Pagination handling\n\n3. Implement a clean API for the Supabase utilities module:\n```typescript\n// supabase-utils.ts\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { DB_TABLES } from './constants';\n\n// Types for database models and app models\nexport interface DBModel {\n  // Common database fields\n  id: string;\n  created_at: string;\n  updated_at: string;\n  // Other common fields\n}\n\nexport interface AppModel {\n  // Common app model fields\n  id: string;\n  createdAt: Date;\n  updatedAt: Date;\n  // Other common fields\n}\n\n// Singleton pattern for Supabase client\nlet supabaseClient: SupabaseClient | null = null;\n\nexport function getSupabaseClient(): SupabaseClient {\n  if (!supabaseClient) {\n    supabaseClient = createClient(\n      process.env.SUPABASE_URL || '',\n      process.env.SUPABASE_KEY || ''\n    );\n  }\n  return supabaseClient;\n}\n\n// Generic data transformation utilities\nexport function transformDBToAppFormat<T extends DBModel, U extends AppModel>(dbModel: T): U {\n  // Implement common transformation logic\n  const appModel = {\n    id: dbModel.id,\n    createdAt: new Date(dbModel.created_at),\n    updatedAt: new Date(dbModel.updated_at),\n    // Transform other fields as needed\n  } as unknown as U;\n  \n  return appModel;\n}\n\nexport function transformAppToDBFormat<T extends AppModel, U extends DBModel>(appModel: T): U {\n  // Implement common transformation logic\n  const dbModel = {\n    id: appModel.id,\n    // Transform other fields as needed\n  } as unknown as U;\n  \n  return dbModel;\n}\n\n// Generic CRUD operations with fallback handling\nexport async function fetchCollection<T>(\n  tableName: string,\n  query: any = {},\n  options: { transformResult?: boolean } = { transformResult: true }\n): Promise<T[]> {\n  try {\n    const supabase = getSupabaseClient();\n    let queryBuilder = supabase.from(tableName).select('*');\n    \n    // Apply filters from query object\n    if (query.filters) {\n      // Apply filters to queryBuilder\n    }\n    \n    // Apply pagination\n    if (query.pagination) {\n      queryBuilder = queryBuilder\n        .range(query.pagination.start, query.pagination.end);\n    }\n    \n    // Apply sorting\n    if (query.sort) {\n      queryBuilder = queryBuilder.order(query.sort.field, {\n        ascending: query.sort.ascending\n      });\n    }\n    \n    const { data, error } = await queryBuilder;\n    \n    if (error) throw error;\n    \n    return options.transformResult \n      ? data.map(item => transformDBToAppFormat(item))\n      : data;\n  } catch (error) {\n    console.error(`Error fetching from ${tableName}:`, error);\n    // Implement fallback logic here\n    return [];\n  }\n}\n\n// Add other common operations: insert, update, delete, etc.\n```\n\n4. Refactor existing collection endpoints to use the new utilities:\n   - Identify all files that contain Supabase operations\n   - Replace direct Supabase calls with the new utility functions\n   - Ensure consistent error handling across all endpoints\n   - Update any collection-specific transformations to extend the base transformations\n\n5. Add specialized utilities for specific collections as needed, while maintaining the common pattern.\n\n6. Update documentation to reflect the new centralized approach to database operations.",
        "testStrategy": "1. Unit Tests:\n   - Create comprehensive unit tests for the Supabase utility functions using Jest or your project's testing framework\n   - Test the singleton pattern for the Supabase client\n   - Test data transformation functions with various input formats\n   - Mock Supabase responses to test error handling and fallback logic\n   - Test query building with different filter combinations\n   - Verify pagination and sorting functionality\n\n2. Integration Tests:\n   - Test the integration between the utility module and actual Supabase instances\n   - Verify that all CRUD operations work correctly with test data\n   - Test edge cases like empty results, large result sets, and malformed data\n   - Ensure fallback mechanisms work as expected when Supabase is unavailable\n\n3. Refactoring Verification:\n   - Create a checklist of all files that were modified to use the new utilities\n   - Verify each endpoint still returns the same data structure after refactoring\n   - Compare response times before and after refactoring to ensure performance is maintained or improved\n   - Check that error handling is consistent across all refactored endpoints\n\n4. End-to-End Tests:\n   - Update or create E2E tests that exercise the collection endpoints\n   - Verify that the application behaves identically after the refactoring\n   - Test the system's resilience when database operations fail",
        "status": "pending",
        "dependencies": [1, 3],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:42.616Z",
      "updated": "2025-08-22T09:30:56.299Z",
      "description": "Consolidate duplicate code patterns and utilities"
    }
  },
  "dead-code-removal": {
    "tasks": [
      {
        "id": 1,
        "title": "Remove Legacy Calendar API Routes",
        "description": "Remove deprecated API routes that use the old globalThis.calendars system which have been replaced by the GUID-based collections system.",
        "details": "This task involves removing the following legacy API routes:\n\n1. `/api/calendars/route.ts`\n2. `/api/calendars/[id]/route.ts`\n3. `/api/calendars/[id]/test/route.ts`\n4. `/api/sync/route.ts`\n\nImplementation steps:\n1. Verify that these routes are no longer referenced in the codebase by performing a comprehensive search for any imports or calls to these endpoints.\n2. Check for any client-side code that might be making fetch requests to these endpoints.\n3. Ensure that the GUID-based collections system fully replaces the functionality of these routes.\n4. Remove the route files from the project.\n5. Update any relevant documentation to reflect the removal of these endpoints.\n6. If there are any tests specifically for these routes, either remove them or update them to test the new GUID-based system instead.\n7. Update API documentation or OpenAPI specs if they exist to remove references to these deprecated endpoints.\n\nNote: Before deletion, it may be helpful to review the implementation of these routes to ensure all functionality has been properly migrated to the new system.",
        "testStrategy": "1. Verify removal of files:\n   - Confirm that `/api/calendars/route.ts`, `/api/calendars/[id]/route.ts`, `/api/calendars/[id]/test/route.ts`, and `/api/sync/route.ts` have been deleted from the codebase.\n\n2. Verify no references remain:\n   - Run a project-wide search for any imports or references to these routes.\n   - Check for any fetch calls or API requests to these endpoints.\n\n3. Functional testing:\n   - Test the GUID-based collections system to ensure it properly handles all the functionality that was previously managed by the removed routes.\n   - Verify that calendar data can still be created, read, updated, and deleted through the new system.\n   - Test calendar synchronization to ensure it works correctly with the new implementation.\n\n4. Regression testing:\n   - Run the existing test suite to ensure no functionality has been broken by the removal.\n   - Check that the application builds successfully without errors.\n\n5. API documentation verification:\n   - Ensure API documentation has been updated to remove references to these deprecated endpoints.\n   - Confirm that new endpoints are properly documented.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Update or Remove Outdated Test File for Homepage",
        "description": "Fix or remove the outdated test file src/__tests__/example.test.tsx which contains tests for non-existent components and expects \"Development Dashboard\" instead of \"Calendar Aggregator\" on the homepage.",
        "details": "This task involves addressing issues with an outdated test file that no longer matches the current application state:\n\n1. First, examine the test file at `src/__tests__/example.test.tsx` to understand what it's testing and how it's structured.\n\n2. Determine whether the test should be:\n   - Updated to match current application behavior\n   - Removed entirely if it's testing deprecated functionality\n\n3. If updating:\n   - Replace expectations for \"Development Dashboard\" with \"Calendar Aggregator\"\n   - Update or remove tests for non-existent components\n   - Ensure imports reference valid components\n   - Adjust test selectors to match current DOM structure\n   - Update any mocks or fixtures to reflect current data structures\n\n4. If removing:\n   - Check if any other tests depend on this file\n   - Ensure removal won't affect test coverage metrics significantly\n   - Document the removal in PR comments\n\n5. Consider adding new tests that properly validate the current homepage functionality if appropriate.\n\n6. Update any related documentation that might reference this test file.\n\nImplementation considerations:\n- Use React Testing Library best practices for any updated tests\n- Focus on testing behavior rather than implementation details\n- Ensure tests are resilient to minor UI changes",
        "testStrategy": "1. If updating the test:\n   - Run the updated test file in isolation: `npm test -- src/__tests__/example.test.tsx`\n   - Verify all tests pass with the new expectations\n   - Ensure test coverage remains the same or improves\n   - Run the full test suite to confirm no regressions\n\n2. If removing the test:\n   - After removal, run the full test suite to verify no other tests were dependent on it\n   - Check test coverage reports to understand impact on overall coverage\n   - Document the removal decision and rationale\n\n3. Manual verification:\n   - Open the homepage and confirm it displays \"Calendar Aggregator\" as expected\n   - Verify any components being tested actually exist in the current implementation\n   - Compare test expectations with actual UI behavior\n\n4. Code review:\n   - Have another developer review the changes to confirm the approach (update vs. remove)\n   - Ensure PR description clearly explains the rationale for the chosen approach",
        "status": "pending",
        "dependencies": [1],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Remove Obsolete Documentation Files",
        "description": "Remove outdated planning documentation files that describe features which have already been implemented and are no longer needed in the codebase.",
        "details": "This task involves removing the following obsolete documentation files from the repository:\n\n1. `docs/GUID_WORKFLOW_PLAN.md` - Contains planning information for the GUID-based collections system that has now been implemented.\n2. `docs/IMPLEMENTATION_PLAN.md` - Contains outdated implementation plans for features that are now complete.\n3. `PROJECT_GUIDE.md` - Contains project planning information that is no longer relevant.\n\nImplementation steps:\n1. Verify that these documentation files are truly obsolete by:\n   - Confirming that all features described in these documents have been fully implemented\n   - Checking if any ongoing development still references these documents\n   - Ensuring that no current tasks depend on information in these files\n\n2. Before deletion, consider if any content from these files should be:\n   - Archived elsewhere for historical reference\n   - Migrated to current documentation\n   - Preserved in release notes or changelogs\n\n3. Remove the files using git:\n   ```bash\n   git rm docs/GUID_WORKFLOW_PLAN.md\n   git rm docs/IMPLEMENTATION_PLAN.md\n   git rm PROJECT_GUIDE.md\n   ```\n\n4. Update any references to these files in:\n   - README.md or other documentation\n   - Contributing guidelines\n   - Developer onboarding materials\n\n5. Commit the changes with a clear message explaining the removal:\n   ```bash\n   git commit -m \"Remove obsolete documentation files as features are now implemented\"\n   ```",
        "testStrategy": "1. Verify file removal:\n   - Confirm that `docs/GUID_WORKFLOW_PLAN.md`, `docs/IMPLEMENTATION_PLAN.md`, and `PROJECT_GUIDE.md` have been deleted from the repository\n   - Verify these files no longer appear in the project directory structure\n\n2. Check for broken references:\n   - Run a project-wide search for any references to the removed files:\n     ```bash\n     grep -r \"GUID_WORKFLOW_PLAN.md\" .\n     grep -r \"IMPLEMENTATION_PLAN.md\" .\n     grep -r \"PROJECT_GUIDE.md\" .\n     ```\n   - Ensure any links to these files in other documentation have been updated or removed\n\n3. Verify documentation completeness:\n   - Confirm that any critical information from the removed files has been preserved in current documentation if needed\n   - Check that developers can still find necessary information without these files\n\n4. Repository validation:\n   - Run any documentation validation tools or linters to ensure no broken links remain\n   - Verify that the project builds correctly without these files",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Remove Unused Calendar Utility Functions",
        "description": "Remove unused functions from calendar-related utility files including isValidICalUrl(), combineICalFeedsFromParsedEvents(), and evaluate if fetchCalendarEvents() should remain as a public API.",
        "details": "This task involves removing unused functions from calendar utility files to improve code maintainability and reduce technical debt:\n\n1. Remove `isValidICalUrl()` function from `calendar-utils.ts`:\n   - Locate the function in the file\n   - Check for any imports or references to this function throughout the codebase\n   - If no references exist, remove the function entirely\n   - If references exist, document them for further evaluation\n   - Update any exports that might include this function\n\n2. Remove `combineICalFeedsFromParsedEvents()` function from `ical-combiner.ts`:\n   - Locate the function in the file\n   - Check for any imports or references to this function throughout the codebase\n   - If no references exist, remove the function entirely\n   - If references exist, document them for further evaluation\n   - Update any exports that might include this function\n\n3. Evaluate `fetchCalendarEvents()` in `calendar-fetcher.ts`:\n   - Determine if this function is being used anywhere in the codebase\n   - If it's not used, remove it entirely\n   - If it is used but should not be public, consider:\n     - Moving it to a more appropriate location\n     - Making it a private function (if the language supports it)\n     - Documenting why it remains if it needs to stay\n\n4. Update any related documentation or comments that reference these functions\n\n5. Ensure that removing these functions doesn't break any type definitions or interfaces\n\n6. Consider updating unit tests that might be testing these functions:\n   - Remove tests for functions that are being removed\n   - Update tests that might indirectly use these functions",
        "testStrategy": "1. Static code analysis:\n   - Run a linter to ensure no syntax errors were introduced\n   - Run TypeScript compiler to verify no type errors were introduced\n\n2. Verify function removal:\n   - Confirm that `isValidICalUrl()` has been removed from `calendar-utils.ts`\n   - Confirm that `combineICalFeedsFromParsedEvents()` has been removed from `ical-combiner.ts`\n   - Verify that `fetchCalendarEvents()` has either been removed or properly documented if kept\n\n3. Test for broken references:\n   - Run a project-wide search for any remaining references to the removed functions\n   - Ensure no imports are attempting to import the removed functions\n\n4. Run existing tests:\n   - Run the test suite to ensure that removing these functions hasn't broken any existing functionality\n   - Pay special attention to calendar-related tests\n\n5. Manual testing:\n   - Test calendar-related functionality in the application to ensure everything still works as expected\n   - Verify that calendar data is still properly fetched, combined, and displayed\n\n6. Code review:\n   - Have another developer review the changes to ensure nothing important was accidentally removed",
        "status": "pending",
        "dependencies": [1],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:47.850Z",
      "updated": "2025-08-22T09:29:16.160Z",
      "description": "Remove obsolete API routes, unused functions, and outdated files"
    }
  },
  "config-optimization": {
    "tasks": [
      {
        "id": 1,
        "title": "Optimize Tailwind Configuration",
        "description": "Remove unused Tailwind plugins, reduce the safelist, and clean up color definitions to improve build performance and reduce CSS bundle size.",
        "details": "This task involves optimizing the Tailwind CSS configuration to improve build performance and reduce bundle size:\n\n1. Remove unused plugins:\n   - Remove `@tailwindcss/forms` plugin from the Tailwind config\n   - Remove `@tailwindcss/typography` plugin from the Tailwind config\n   - Uninstall these packages from package.json if they're no longer needed elsewhere\n\n2. Optimize the safelist:\n   - Review the current safelist with 49 classes\n   - Determine which classes are actually needed for dynamic content\n   - Remove unnecessary classes from the safelist\n   - Consider using regex patterns for dynamic class names instead of listing each variant\n\n3. Clean up color definitions:\n   - Review the color palette in the Tailwind config\n   - Remove unused color definitions\n   - Ensure the theme is consistent with the design system\n   - Remember that Tailwind automatically scans content for used classes\n\n4. Update the tailwind.config.js file with these changes:\n```javascript\n// Before\nmodule.exports = {\n  // ... other config\n  plugins: [\n    require('@tailwindcss/forms'),\n    require('@tailwindcss/typography'),\n    // ... other plugins\n  ],\n  safelist: [\n    // 49 classes listed here\n  ],\n  theme: {\n    colors: {\n      // Extensive color definitions\n    }\n  }\n}\n\n// After\nmodule.exports = {\n  // ... other config\n  plugins: [\n    // Only necessary plugins\n  ],\n  safelist: [\n    // Only essential classes or regex patterns\n  ],\n  theme: {\n    colors: {\n      // Streamlined color definitions\n    }\n  }\n}\n```\n\n5. Rebuild the project to ensure everything works correctly after these changes.",
        "testStrategy": "1. Compare build times before and after the optimization:\n   - Run `npm run build` (or equivalent) before making changes and record the time\n   - Run the same build command after changes and verify improved build time\n\n2. Compare CSS bundle size:\n   - Measure the size of the CSS output file before changes\n   - Measure the size after changes and confirm reduction\n\n3. Visual regression testing:\n   - Take screenshots of key pages before changes\n   - Compare with screenshots after changes to ensure no visual regressions\n\n4. Functional testing:\n   - Test all dynamic components that might use classes from the safelist\n   - Verify that dynamically generated classes still work correctly\n   - Test responsive layouts and interactive elements\n\n5. Browser compatibility:\n   - Test in Chrome, Firefox, Safari, and Edge to ensure cross-browser compatibility\n\n6. Run the application's test suite to ensure no functionality is broken\n\n7. Code review:\n   - Have another developer review the changes to ensure no critical classes were removed",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Clean Up globals.css File",
        "description": "Refactor the globals.css file by removing redundant CSS utilities that duplicate Tailwind classes, consolidating glass effect patterns, and eliminating custom responsive classes that replicate Tailwind's native functionality.",
        "details": "This task involves cleaning up the globals.css file to reduce duplication and improve maintainability:\n\n1. Remove redundant CSS utilities:\n   - Identify and remove any custom utility classes that duplicate existing Tailwind classes\n   - Look for properties like margins, paddings, colors, and flexbox utilities that Tailwind already provides\n   - Document each removed class with a comment indicating the Tailwind equivalent\n\n2. Consolidate glass effect patterns:\n   - Identify all instances of glass/frosted glass effect CSS\n   - Create a single, reusable glass effect utility class\n   - Replace all duplicated implementations with the new consolidated class\n   - Consider creating a Tailwind component using @apply if the effect is used frequently\n\n3. Remove custom responsive classes:\n   - Identify custom media query classes like .md-grid-cols-2\n   - Replace them with Tailwind's native responsive variants (e.g., md:grid-cols-2)\n   - Update all component files that use these custom classes to use Tailwind's responsive syntax instead\n\n4. Document changes:\n   - Create a brief documentation section at the top of globals.css explaining the refactoring\n   - List any custom utilities that were kept and why they're still necessary\n\n5. Verify no visual regressions:\n   - Test all affected components across different screen sizes\n   - Ensure the application's appearance remains consistent after changes",
        "testStrategy": "1. Visual regression testing:\n   - Take screenshots of key pages before making changes\n   - Compare with screenshots after changes to ensure visual consistency\n   - Test on multiple screen sizes (mobile, tablet, desktop)\n\n2. CSS bundle size verification:\n   - Measure the size of the CSS bundle before and after changes\n   - Verify a reduction in file size after removing redundant code\n\n3. Browser compatibility testing:\n   - Test the changes in Chrome, Firefox, Safari, and Edge\n   - Ensure the glass effects and responsive behaviors work consistently across browsers\n\n4. Code review checklist:\n   - Verify all removed CSS classes are actually redundant with Tailwind\n   - Confirm all components using custom responsive classes have been updated\n   - Check that the consolidated glass effect works in all instances where it's used\n\n5. Performance testing:\n   - Compare page load times before and after changes\n   - Verify that CSS parsing time has improved",
        "status": "pending",
        "dependencies": [1],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Fix Configuration Files and Module Settings",
        "description": "Remove or properly configure builder.config.json, fix Husky setup by implementing pre-commit hooks or removing the prepare script, and add 'type: module' to package.json to resolve build warnings.",
        "details": "This task involves addressing several configuration issues in the project:\n\n1. Builder.config.json:\n   - Evaluate if builder.config.json is needed for the project\n   - If not needed, remove the file completely\n   - If needed, properly configure it according to the third-party builder tool documentation\n   - Update any related import statements or references in the codebase\n\n2. Fix Husky setup:\n   - Examine the current Husky configuration in package.json (look for \"prepare\" script)\n   - Option A: Properly implement pre-commit hooks\n     - Ensure Husky is correctly installed: `npm install husky --save-dev`\n     - Set up proper pre-commit hooks: `npx husky add .husky/pre-commit \"npm test\"`\n     - Configure hooks to run linting, formatting, or tests before commits\n     - Update the prepare script to: `\"prepare\": \"husky install\"`\n   - Option B: Remove Husky completely\n     - Remove the prepare script from package.json\n     - Uninstall Husky: `npm uninstall husky`\n     - Remove any .husky directory and configuration files\n\n3. Add module type to package.json:\n   - Open package.json\n   - Add `\"type\": \"module\"` to the root level of the JSON object\n   - This will enable ES modules syntax throughout the project\n   - Ensure this change doesn't break existing imports (may need to update some import statements)\n\n4. Test the changes to ensure the build process works correctly without warnings.",
        "testStrategy": "1. Builder.config.json verification:\n   - If removed: Build the project and verify no errors related to missing builder configuration\n   - If configured: Build the project and verify the third-party builder tool works as expected\n   - Check logs for any related warnings or errors\n\n2. Husky setup verification:\n   - If implemented: Make a test commit with intentionally failing tests or lint errors\n   - Verify that the pre-commit hook blocks the commit when tests/lint fail\n   - Fix the intentional errors and verify the commit succeeds\n   - If removed: Verify that commits can be made without Husky-related errors\n\n3. Module type verification:\n   - Run `npm run build` and verify no module-related warnings appear\n   - Test importing modules in different files using ES module syntax\n   - Verify that any dynamic imports still function correctly\n   - Check for any runtime errors related to module resolution\n\n4. Overall build verification:\n   - Run a complete build process\n   - Verify that no configuration-related warnings or errors appear\n   - Compare build time and output size before and after changes to ensure no regression",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-22T09:26:53.003Z",
      "updated": "2025-08-22T09:31:59.944Z",
      "description": "Optimize build configurations and remove unused settings"
    }
  }
}
